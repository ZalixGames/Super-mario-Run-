

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Super Mario Run - Play Online & Earn Money</title>
  <meta name="description" content="Play Super Mario Run online and earn real money. Classic Mario gameplay on browser. No download needed!" />
  <meta name="keywords" content="Super Mario Run, Mario game, Earn money playing, Play Super Mario online, Free Mario Run game, Super Mario browser game" />
  <meta name="author" content="Zalix Games" />
  <meta property="og:title" content="Play Super Mario Run – Earn While You Play!" />
  <meta property="og:description" content="Enjoy classic Mario Run online and earn rewards while having fun!" />
  <meta property="og:image" content="https://supermariorun.site/assets/preview.png" />
  <meta property="og:url" content="https://supermariorun.site" />
  <meta property="og:type" content="website" />
  <meta name="robots" content="index, follow" />


  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#3761bd" />
  <!-- Description already present above, no need to duplicate if identical -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Mario Run" />
  <link rel="manifest" href="./manifest.json" />
  <link rel="apple-touch-icon" href="./20250517_001646.png" />

  <!-- Existing Styles -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- SEO: Structured Data for Video Game -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Super Mario Run - Play Online & Earn Money",
    "url": "https://supermariorun.site",
    "description": "Play Super Mario Run online and earn real money. Classic Mario gameplay on browser. No download needed!",
    "applicationCategory": "Game",
    "operatingSystem": "Web browser",
    "browserRequirements": "Requires HTML5 Canvas and JavaScript",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "genre": ["Arcade game", "Platform game", "Endless runner"],
    "playMode": "SinglePlayer",
    "publisher": {
      "@type": "Organization",
      "name": "Zalix Games"
    },
    "image": "https://supermariorun.site/assets/preview.png",
    "keywords": "Super Mario Run, Mario game, Earn money playing, Play Super Mario online, Free Mario Run game, Super Mario browser game"
  }
  </script>

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          })
          .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }
  </script>
  <!-- Ad Script 1 (Placeholder - REMOVED OLD SCRIPT) -->
  <style>
    /* --- CSS Styles --- */
    /* Basic Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Press Start 2P', cursive; overflow: hidden;
      background: #050505 url('https://www.transparenttextures.com/patterns/stardust.png'); /* Darker background */
      color: #e0e0e0; /* Slightly off-white text */
      margin-bottom: 50px; /* Space for banner */
    }
    canvas { display: block; background-color: #60a5fa; /* Brighter sky blue */ }
    .text-glow { text-shadow: 0 0 4px #fff, 0 0 8px #fff, 0 0 12px #ff38a1, 0 0 16px #ff38a1; } /* Enhanced Pink Glow */
    .box-glow { box-shadow: 0 0 6px rgba(255, 255, 255, 0.7), 0 0 12px rgba(255, 56, 161, 0.6); } /* Enhanced Pink Glow */

    /* --- Enhanced General Button Styles --- */
    /* NOTE: #spinBtn inside .wheel-hub overrides many of these */
    .game-btn {
      padding: 14px 28px; /* Slightly larger padding */
      margin: 10px;
      font-size: 14px; /* Keep font size readable */
      border: none;
      border-radius: 10px; /* Slightly more rounded */
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease; /* Faster transform */
      background: linear-gradient(145deg, #ff5252, #e53935); /* Base Red Gradient */
      color: #ffffff; /* Pure white text */
      font-family: 'Press Start 2P', cursive;
      text-transform: uppercase;
      text-shadow: 2px 2px 3px rgba(0,0,0,0.8); /* Sharper text shadow */
      border-bottom: 5px solid #b71c1c; /* Darker, thicker bottom border */
      box-shadow: 0 5px 8px rgba(0, 0, 0, 0.3); /* Enhanced shadow */
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1.3; /* Adjusted line-height */
      text-decoration: none;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    .game-btn:hover:not(:disabled) {
      transform: translateY(-3px) scale(1.04); /* More pronounced hover effect */
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 18px rgba(255, 82, 82, 0.7); /* Enhanced shadow + red glow */
      background: linear-gradient(145deg, #ff6161, #ef5350); /* Slightly brighter hover gradient */
    }
    .game-btn:active:not(:disabled) {
         transform: translateY(1px) scale(1.01); /* Subtle press effect */
         border-bottom-width: 3px; /* Reduce border on press */
         box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3); /* Reduced shadow on press */
    }
    .game-btn:disabled {
        background: linear-gradient(145deg, #666, #444); /* Dark grey gradient */
        cursor: not-allowed;
        border-bottom-color: #222; /* Very dark border */
        box-shadow: none; transform: none; opacity: 0.6; /* More faded */
        color: #aaa; /* Grey text */
        text-shadow: none;
    }

    /* --- Google Sign-in Panel Styles --- */
    #googleSignInPanel {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: url('https://i.imgur.com/nxRZ03R.png') no-repeat center center;
        background-size: cover; background-color: rgba(0, 0, 0, 0.75); /* Slightly darker overlay */
        background-blend-mode: darken; z-index: 100; display: none;
        flex-direction: column; justify-content: center; align-items: center;
        color: #fff; padding: 20px; text-align: center;
    }
     #googleSignInPanel h2 {
        font-size: 2.8em; /* Slightly larger */
        color: #ff38a1; /* Consistent pink */
        margin-bottom: 35px;
        text-shadow: 4px 4px 0px #000, 0 0 18px #ff38a1, 0 0 25px #ff38a1; /* Enhanced text shadow */
    }
    #googleSignInBtn {
        background: linear-gradient(145deg, #4f8ef7, #3678e6); /* Brighter Google blue */
        border-bottom-color: #1a5ac4;
        color: white; width: 300px; /* Slightly wider */
        padding: 16px 28px; /* More padding */
        font-size: 16px;
        display: inline-flex; align-items: center; justify-content: center;
    }
    #googleSignInBtn img { width: 26px; height: 26px; margin-right: 18px; background-color: white; padding: 3px; border-radius: 3px; }
    #googleSignInBtn:hover:not(:disabled) {
        background-image: linear-gradient(145deg, #5a95f8, #4185f4);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(66, 133, 244, 0.7); /* Blue glow on hover */
    }
     #guestButtonAlt {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d); /* Muted grey/blue */
        border-bottom-color: #525e5f;
        width: 300px; margin-top: 15px;
     }
     #guestButtonAlt:hover:not(:disabled) {
         background-image: linear-gradient(145deg, #aab5b6, #95a5a6);
         box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 15px rgba(149, 165, 166, 0.6); /* Grey glow */
     }

    /* --- Main Menu --- */
    #mainMenu {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: url('https://i.imgur.com/KFWJlte.png') no-repeat center center; background-size: cover;
      background-color: rgba(10, 10, 10, 0.6); background-blend-mode: darken; /* Add subtle overlay */
      z-index: 30; display: none; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; padding: 20px; text-align: center; padding-top: 90px; /* Adjusted padding */
    }
    /* --- Adjusted Coin Counter Display --- */
    #topRightStatus {
      position: absolute; top: 15px; right: 15px;
      background: rgba(0,0,0,0.88); /* Darker, less transparent */
      padding: 8px; /* Adjusted Padding */
      border-radius: 10px; /* Match button radius */
      z-index: 35;
      border: 2px solid #b8860b; /* Darker gold border */
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.6), inset 0 0 5px rgba(0,0,0,0.5); /* Gold glow + inner shadow */
      display: none; /* Handled by JS */
      display: inline-flex; /* Changed from none */
      align-items: center;
       font-family: 'Press Start 2P', cursive; /* Use game font for numbers */
       line-height: 1.2;
    }
     /* --- New styles for Coin/PKR display boxes --- */
     #topRightStatus .status-box {
         display: flex;
         align-items: center;
         padding: 4px 8px; /* Padding inside each box */
         border-radius: 8px; /* Rounded corners for boxes */
         background: rgba(255,255,255,0.05); /* Subtle background */
         border: 1px solid rgba(255,255,255,0.1); /* Subtle border */
         box-shadow: inset 0 0 4px rgba(0,0,0,0.5);
         font-size: 14px; /* Match overall status text size */
     }
     #topRightStatus #coinBox {
         color: #FFD700; /* Gold for coins */
     }
      #topRightStatus #pkrBox {
         margin-left: 10px; /* Space between coin and PKR boxes */
         color: #66bb6a; /* Greenish for PKR Balance */
      }
     #topRightStatus img {
         width: 18px; /* Smaller icons */
         height: 18px;
         margin-right: 5px; /* Space between icon and text */
         vertical-align: middle;
         filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.8));
     }
      /* Ensure text inside boxes uses game font */
     #topRightStatus .status-box span {
         font-family: 'Press Start 2P', cursive;
     }

    /* --- End Adjusted Coin Counter Display --- */
    #settingsBtn {
      position: absolute; top: 15px; left: 15px; background: rgba(30,30,30,0.85); /* Slightly less dark */
      border: 2px solid #bbb;
      border-radius: 50%; cursor: pointer; z-index: 35; width: 50px; height: 50px; /* Slightly larger */
      display: none; /* Default hidden */
      justify-content: center; align-items: center; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    #settingsBtn svg { width: 26px; height: 26px; fill: #ddd; }
    #settingsBtn:hover {
        transform: rotate(60deg) scale(1.12); /* Faster rotation, larger scale */
        box-shadow: 0 0 18px rgba(255,255,255,0.8); /* Brighter glow */
        border-color: #fff;
    }
    #mainMenu .menu-btn { width: 250px; margin-bottom: 18px; } /* Wider buttons, more spacing */
    /* Specific Main Menu Button Colors */
    #mainMenu #startBtn { background: linear-gradient(145deg, #ff5252, #e53935); border-bottom-color: #b71c1c; } /* Base Red */
    #mainMenu #startBtn:hover:not(:disabled) { background: linear-gradient(145deg, #ff6161, #ef5350); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 18px rgba(255, 82, 82, 0.7); }

    #mainMenu #withdrawBtn { background: linear-gradient(145deg, #4caf50, #388e3c); border-bottom-color: #1b5e20; display: none; } /* Positive Green */
    #mainMenu #withdrawBtn:hover:not(:disabled) { background-image: linear-gradient(145deg, #66bb6a, #43a047); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(76, 175, 80, 0.7); } /* Green glow */

    #mainMenu #inviteFriend { background: linear-gradient(145deg, #2196f3, #1976d2); border-bottom-color: #0d47a1; display: none; } /* Action Blue */
    #mainMenu #inviteFriend:hover:not(:disabled) { background-image: linear-gradient(145deg, #42a5f5, #1e88e5); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(33, 150, 243, 0.7); } /* Blue glow */

    #mainMenu #infoBtn { background: linear-gradient(145deg, #ffc107, #ffa000); border-bottom-color: #ff6f00; } /* Info Yellow/Amber */
    #mainMenu #infoBtn:hover:not(:disabled) { background-image: linear-gradient(145deg, #ffca28, #ffb300); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(255, 193, 7, 0.7); } /* Yellow glow */

    #mainMenu #logoutBtn { background: linear-gradient(145deg, #9e9e9e, #757575); border-bottom-color: #424242; display: none; } /* Neutral Grey */
    #mainMenu #logoutBtn:hover:not(:disabled) { background-image: linear-gradient(145deg, #bdbdbd, #9e9e9e); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 15px rgba(158, 158, 158, 0.6); } /* Grey glow */

    /* NEW: Android App Button Style */
     #mainMenu #androidAppBtn { background: linear-gradient(145deg, #42b72a, #36a420); border-bottom-color: #277b18; display: none;} /* WhatsApp Green-like */
     #mainMenu #androidAppBtn:hover:not(:disabled) { background-image: linear-gradient(145deg, #57c341, #49b22f); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(66, 183, 42, 0.7); } /* Green glow */


    /* --- Bottom Fixed Buttons (WhatsApp & Spin) --- */
    .fixed-bottom-btn {
       position: fixed;
       bottom: 65px; /* Adjust based on banner height + padding */
       z-index: 900; /* High z-index */
       width: 60px; /* Slightly larger */
       height: 60px;
       border-radius: 50%; /* Circular shape */
       display: none; /* Handled by JS */
       justify-content: center;
       align-items: center;
       box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
       cursor: pointer;
       transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
       text-decoration: none; /* Remove underline */
       border: 3px solid #ccc; /* Default border */
       padding: 5px; /* Padding inside for the image */
    }
    .fixed-bottom-btn img {
        width: 100%; /* Make image fill the button */
        height: 100%;
        object-fit: contain; /* Ensure image is scaled correctly */
         border-radius: 50%; /* Make image circular */
    }
    .fixed-bottom-btn:hover:not(:disabled) {
       transform: scale(1.15); /* Grow slightly on hover */
       box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
    }
     .fixed-bottom-btn:active:not(:disabled) {
         transform: scale(1.05); /* Shrink slightly on click */
         box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
     }

    /* WhatsApp Button Specifics */
     #whatsappBtn {
        right: 20px;
        background-color: #25D366; /* WhatsApp Green */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), 0 0 15px rgba(37, 211, 102, 0.6); /* Shadow and green glow */
        border-color: #128C7E; /* Darker green border */
     }
     #whatsappBtn:hover {
         box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5), 0 0 20px rgba(37, 211, 102, 0.8); /* More pronounced shadow/glow */
     }

     /* Spin Wheel Button Specifics (Keeping base fixed-bottom-btn styles) */
     #spinWheelBtn {
         right: 95px; /* Position next to WhatsApp button */
         /* No specific background/border needed here, uses fixed-bottom-btn defaults */
         background: none; /* Reset background */
         border: none; /* Reset border */
         box-shadow: none; /* Reset shadow */
     }
      #spinWheelBtn img {
          /* Specific styles for the image within the spin wheel button */
          filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.7)); /* Gold shadow/glow for the icon */
      }
     /* Hover/active will use fixed-bottom-btn defaults */


    /* --- Game Over Menu --- */
    #gameOverMenu {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.88); /* Darker overlay */
      z-index: 40; display: none; flex-direction: column; justify-content: center; align-items: center;
      color: #f44336; /* Consistent Error Red */
      padding: 20px; text-align: center;
    }
    #gameOverMenu h2 {
        font-size: 4.5em; /* Larger text */
        text-shadow: 5px 5px 0px #000, 0 0 25px #ff0000, 0 0 35px #ff0000; /* More intense shadow/glow */
        margin-bottom: 25px;
    }
    #gameOverMenu p {
        font-size: 1.8em; /* Larger score text */
        color: #fff;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px #000; /* Sharper shadow */
    }
    #gameOverMenu .menu-btn { width: 220px; } /* Standard button size */
    #gameOverMenu #restartBtn {
        background: linear-gradient(145deg, #4caf50, #388e3c); /* Positive Green */
        border-bottom-color: #1b5e20;
    }
    #gameOverMenu #restartBtn:hover:not(:disabled) {
        background-image: linear-gradient(145deg, #66bb6a, #43a047);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(76, 175, 80, 0.7); /* Green glow */
    }
    #gameOverMenu #backMenuBtn {
        background: linear-gradient(145deg, #2196f3, #1976d2); /* Action Blue */
        border-bottom-color: #0d47a1;
    }
    #gameOverMenu #backMenuBtn:hover:not(:disabled) {
        background-image: linear-gradient(145deg, #42a5f5, #1e88e5);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(33, 150, 243, 0.7); /* Blue glow */
    }

    /* --- Modal Common Styles --- */
    /* Use Tailwind classes where possible alongside these */
    .modal { display: none; position: fixed; z-index: 70; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.75); backdrop-filter: blur(6px); } /* Slightly stronger blur */
    .modal .modal-content {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        /* Background, Padding, Border-radius, Border, Box-shadow applied via Tailwind */
        width: 90%; color: #eee; text-align: center;
        max-width: 450px; /* Max width for modal as seen in image */
        max-height: 85vh; overflow-y: auto;
         /* Font family might be overridden by specific modal needs or elements inside */
    }
     /* Close button specific style */
     .modal .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 1.8em;
        font-weight: bold;
        color: #bbb; /* Lighter color for close */
        cursor: pointer;
        background: none;
        border: none;
        padding: 5px;
        line-height: 1;
        z-index: 10; /* Ensure it's clickable */
     }
    .modal h2 {
        /* Font size, color, text-shadow might use custom CSS for specific look */
        margin-bottom: 25px; /* More space */
        font-size: 1.5em; /* Larger title */
        color: #ff38a1; /* Consistent Pink */
        text-shadow: 2px 2px 2px #000, 0 0 8px #ff38a1; /* Sharper shadow + glow */
        font-family: 'Press Start 2P', cursive; /* Keep game font for modal titles */
    }
    /* Modal button styles - these apply to .game-btn *within* a modal-content, but NOT to #spinBtn inside the hub */
    .modal button.game-btn { width: 100%; margin: 10px 0; padding: 12px 20px; font-size: 13px; }
    .modal input[type="text"], .modal input[type="email"], .modal input[type="password"], .modal input[type="number"] {
        width: 100%; padding: 12px; margin-top: 8px; margin-bottom: 18px; /* Adjusted spacing */
        border: 2px solid #555; border-radius: 8px; /* Rounded input */
        background: #333; color: #fff; font-family: 'Arial', sans-serif; font-size: 16px; outline: none;
        transition: border-color 0.3s, box-shadow 0.3s;
    }
    .modal input:focus { border-color: #ff38a1; box-shadow: 0 0 10px rgba(255, 56, 161, 0.7); } /* Pink focus glow */
    .modal input[type="radio"] { margin-right: 10px; vertical-align: middle; transform: scale(1.2); /* Larger radio */ }
    .modal label input[type="radio"] { display: inline; margin-bottom: 0; }
    .modal .payment-options label { margin-bottom: 12px; display: block; font-family: Arial, sans-serif; font-size: 15px; } /* Arial for payment options */
    #redeemSubmitBtn {
         background: linear-gradient(145deg, #4caf50, #388e3c); /* Green */
         border-bottom-color: #1b5e20; width: 100%; margin-top: 25px; font-size: 15px; padding: 14px 24px; /* Adjust padding */
     }
    #redeemSubmitBtn:hover:not(:disabled) {
        background-image: linear-gradient(145deg, #66bb6a, #43a047);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(76, 175, 80, 0.7); /* Green glow */
    }
    #redeemSubmitBtn:disabled { /* Use general disabled style */
        background: linear-gradient(145deg, #666, #444); cursor: not-allowed; border-bottom-color: #222;
        box-shadow: none; transform: none; opacity: 0.6; color: #aaa; text-shadow: none;
    }

    /* --- Info Modal Styles --- */
    #infoModal .modal-content h2 { color: #2196f3; } /* Blue Title */
    #infoModal .modal-content p { margin: 18px 0; font-family: 'Arial', sans-serif; font-size: 15px; line-height: 1.7; color: #ddd; text-align: left; padding-bottom: 10px; border-bottom: 1px solid #444; }
    #infoModal .modal-content p:last-child { border-bottom: none; }
    #infoModal .modal-content p strong { color: #fff; }
    #infoModal .modal-content .highlight { color: #ffee58; font-weight: bold; /* Brighter Yellow Highlight */ }

    /* --- Withdrawal History Modal Styles --- */
    #withdrawalHistoryModal .modal-content h2 { color: #ffc107; } /* Amber Title */
    #historyList { margin-top: 25px; max-height: 55vh; overflow-y: auto; padding-right: 15px; text-align: left; font-family: Arial, sans-serif; font-size: 14px; line-height: 1.6; }
    .history-item { background: #2a2a2a; border: 1px solid #4f4f4f; border-radius: 8px; padding: 14px 18px; margin-bottom: 12px; color: #ccc; display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    .history-item span { display: block; margin-bottom: 5px; font-size: 13px; }
    .history-item .details { flex-grow: 1; margin-right: 15px; }
    .history-item .details span:first-child { font-weight: bold; color: #eee; font-size: 14px; } /* Highlight amount */
    .history-item .status { font-family: 'Press Start 2P', cursive; font-size: 11px; padding: 5px 10px; border-radius: 5px; text-transform: uppercase; min-width: 90px; text-align: center; margin-top: 5px; font-weight: bold; letter-spacing: 0.5px; }
    .history-item .status-pending { background-color: #ffa000; color: #4d3f21; border: 1px solid #e67e22;} /* Amber */
    .history-item .status-approved { background-color: #4caf50; color: #1b5e20; border: 1px solid #10ac84;} /* Green */
    .history-item .status-rejected { background-color: #f44336; color: #5e141e; border: 1px solid #c0392b;} /* Red */
    .history-item .date { font-size: 11px; color: #999; width: 100%; text-align: right; margin-top: 6px; }
    #historyList .no-history { color: #888; text-align: center; padding: 25px; font-size: 1.1em; font-style: italic;}

     /* --- Complete Profile Modal Styles --- */
    #completeProfileModal .modal-content h2 { color: #4caf50; } /* Green Title */
    #completeProfileModal .modal-content p { margin-bottom: 18px; font-family: Arial, sans-serif; line-height: 1.6; font-size: 15px; text-align: left; color: #ddd; }
    #completeProfileModal .modal-content p.subtle { font-size: 12px; color: #aaa; font-style: italic; margin-top: -12px; }
    #completeProfileModal .modal-content label { font-family: 'Press Start 2P', cursive; font-size: 13px; }
    #completeProfileModal .modal-content input[type="text"] { margin-bottom: 25px; border-radius: 8px; padding: 12px; }
    #completeProfileModal #saveProfileBtn { background: linear-gradient(145deg, #4caf50, #388e3c); border-bottom-color: #1b5e20; } /* Green */
    #completeProfileModal #saveProfileBtn:hover:not(:disabled) { background-image: linear-gradient(145deg, #66bb6a, #43a047); box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(76, 175, 80, 0.7); }

    /* --- Ad Container Styles --- */
    #bannerAdContainer { position: fixed; bottom: 0; left: 0; width: 100%; height: 50px; background-color: #080808; z-index: 1000; display: flex; justify-content: center; align-items: center; overflow: hidden; border-top: 3px solid #333; }
    #bannerAdContainer iframe { max-width: 100%; }
    #interstitialAdOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.92); z-index: 2000; display: none; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; font-family: 'Press Start 2P', cursive; padding: 20px; backdrop-filter: blur(4px); }
    #interstitialAdOverlay p#adInfoText { font-size: 1.2em; margin-bottom: 30px; color: #eee; line-height: 1.6; text-shadow: 1px 1px 2px #000; }
    #interstitialAdCloseButton { /* Use game-btn styles */
        padding: 14px 28px; font-size: 1em; cursor: pointer;
        background: linear-gradient(145deg, #f44336, #d32f2f); border-bottom-color: #b71c1c; /* Error Red */
        color: white; border-radius: 10px; font-family: 'Press Start 2P', cursive;
        display: none; text-transform: uppercase; margin-top: 25px;
        text-shadow: 2px 2px 3px rgba(0,0,0,0.8); border: none;
        box-shadow: 0 5px 8px rgba(0, 0, 0, 0.3);
    }
    #interstitialAdCloseButton:hover { /* Match game-btn hover */
        transform: translateY(-3px) scale(1.04);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 18px rgba(244, 67, 54, 0.7); /* Red glow */
        background: linear-gradient(145deg, #ef5350, #e53935);
    }
    #interstitialAdTimer { margin-top: 18px; font-size: 0.9em; color: #bbb; }
    #interstitialAdOverlay p.skip-info { font-size: 0.8em; color: #aaa; margin-top: 35px; font-family: Arial, sans-serif; line-height: 1.5; }

    /* --- Status Message Container --- */
    #statusMessageContainer {
        display: none; position: fixed; top: 15px; left: 50%; transform: translateX(-50%);
        background-color: rgba(10, 10, 10, 0.92); /* Darker background */
        color: white; padding: 14px 28px; /* More padding */
        border-radius: 10px; z-index: 5000; font-family: 'Press Start 2P', cursive; font-size: 1.0em; /* Larger font */
        text-align: center; border: 3px solid #fff; /* Thicker border */
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
        opacity: 0;
        transition: opacity 0.4s ease-in-out, top 0.4s ease-in-out, transform 0.4s ease-in-out;
        max-width: 90%; pointer-events: none; letter-spacing: 0.5px;
    }
    #statusMessageContainer.show {
        display: block; opacity: 1; top: 30px; /* Start slightly higher */
        transform: translateX(-50%) scale(1); /* Scale in */
    }
    /* Status colors matching button themes */
    #statusMessageContainer.success { border-color: #4caf50; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6), 0 0 15px rgba(76, 175, 80, 0.6); } /* Green */
    #statusMessageContainer.error { border-color: #f44336; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6), 0 0 15px rgba(244, 67, 54, 0.6); } /* Red */
    #statusMessageContainer.info { border-color: #2196f3; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6), 0 0 15px rgba(33, 150, 243, 0.6); } /* Blue */


    /* --- Spin Wheel Styles (MIXED Tailwind and Custom) --- */
    /* Modal Content adjusted using Tailwind classes in HTML */
    #spinWheelModal .modal-content {
         /* Retain core positioning and max-height/overflow from existing CSS */
         /* Tailwind classes for background, padding, rounded, border, shadow applied directly in HTML */
         font-family: Arial, sans-serif; /* Use a more readable font for modal text */
         /* Override default h2 color for this modal */
         --tw-text-opacity: 1;
         color: rgb(255 255 255 / var(--tw-text-opacity)); /* White title */
         text-shadow: 2px 2px 2px rgba(0,0,0,0.7); /* Simple shadow */
         display: flex; /* Use flex to arrange content vertically */
         flex-direction: column;
         align-items: center; /* Center items horizontally */
         overflow-y: hidden; /* Prevent modal content from scrolling inside */
         padding-bottom: 15px; /* Reduce padding at the bottom */
    }
    #spinWheelModal h2 {
        /* Overridden above in .modal-content */
        margin-bottom: 15px; /* Slightly less margin below title */
        font-family: 'Press Start 2P', cursive; /* Keep game font for title */
        color: #ff38a1; /* Pink glow title as in image */
        text-shadow: 4px 4px 0px #000, 0 0 18px #ff38a1, 0 0 25px #ff38a1; /* Enhanced text shadow */
    }
     #spinWheelModal .close-btn {
          color: #999; /* Darker close button as in image */
     }

    .spin-wheel-container {
        position: relative; /* Needed for pointer positioning and inner elements */
        /* Size, margin, background, border, shadow applied via Tailwind classes in HTML */
        display: flex; /* Use flexbox to center the wheel */
        justify-content: center;
        align-items: center;
        /* Need to ensure it's square and responsive */
         width: min(80vw, 300px); /* Make it responsive, max 300px */
         height: min(80vw, 300px); /* Keep it square */
         margin-top: 20px; /* Space below title */
         margin-bottom: 0; /* Remove margin bottom, info text is below */
    }

    .wheel {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        position: relative; /* Needed for absolute positioning of segments */
        overflow: hidden; /* Hide segment overflow */
        /* transition handled by JS */
        /* BACKGROUND IS NOW AN IMAGE */
         background-image: url('./Picsart_25-06-03_22-57-40-978.png'); /* Local image path */
         background-size: cover; /* Ensure image covers the circle */
         background-position: center; /* Center the image */
         background-repeat: no-repeat; /* Do not repeat the image */
         /* Removing border/shadow from the wheel element itself as it's part of the image */
         border: none;
         box-shadow: none;
         transition: transform 5s cubic-bezier(0.25, 0.1, 0.25, 1); /* Keep transition here for JS animation */
    }

     /* Segments are text containers OVER the spinning background image */
     /* Positioning relative to the wheel container for radial text */
     .segment {
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         /* No rotation here - text rotation happens on the prize-text inside */
         /* The segment div just provides context for the prize-text positioning */
     }
     .segment .prize-text {
         position: absolute; /* Position absolutely within the segment (which covers the wheel) */
         top: 50%; /* Start at the vertical center of the wheel container */
         left: 50%; /* Start at the horizontal center of the wheel container */
         transform: translate(-50%, -50%); /* Translate back to truly center the element's origin for rotation */

         white-space: nowrap; /* Prevent text wrapping */
         font-size: 12px; /* Adjust size */
         font-family: Arial, sans-serif; /* Use a common sans-serif like in image */
         font-weight: bold; /* Make text bold */
         color: #ffffff; /* White color */
         text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* Stronger text shadow for readability over image */

         z-index: 1; /* Ensure text is above segment background image */
         user-select: none; /* Prevent selecting text during spin */
         pointer-events: none; /* Don't interfere with button clicks */

         /* This transform will be set by JS for positioning and radial rotation */
         transform-origin: 50% 50%; /* Default transform origin is center */
     }


    /* --- Wheel Hub (The small inner circle) --- */
    .wheel-hub {
         position: absolute;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         width: 60px; /* Increased size to better fit button */
         height: 60px; /* Increased size */
         border-radius: 50%;
         background-color: #212121; /* Dark background */
         border: 6px solid #444; /* Border color */
         box-shadow: 0 0 8px rgba(0,0,0,0.6), inset 0 0 6px rgba(255,255,255,0.1); /* Shadow */
         z-index: 4; /* Above wheel segments but below pointer */
         /* Add flexbox to center content (the button) */
         display: flex;
         justify-content: center;
         align-items: center;
         overflow: hidden; /* Hide button overflow if slightly too big */
    }


    /* --- REMOVED Pointer CSS --- */
     .pointer {
         display: none; /* Hide the red pointer */
     }


     /* Spin Button (Now located inside the hub) */
     #spinBtn {
         /* Override default game-btn styles for position/size/appearance */
         position: static; /* Remove absolute positioning */
         transform: none !important; /* Remove translations/scales that conflict with centering */
         width: 100%; /* Fill the hub size */
         height: 100%; /* Fill the hub size */
         margin: 0; /* Remove margins */
         padding: 0; /* Remove padding */
         font-size: 12px; /* Adjust font size to fit "Spin" */
         border: none !important; /* Remove all borders */
         border-radius: 50%; /* Make it circular */
         color: #fff; /* White text */
         font-family: 'Press Start 2P', cursive; /* Keep game font */
         text-transform: uppercase; /* Keep uppercase */
         text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Simple text shadow */
         box-shadow: none !important; /* Remove box shadow from button itself */

         /* Green color and glow matching image */
         background: radial-gradient(circle, #66bb6a 0%, #4caf50 100%); /* Radial gradient for glow effect */
         outline: 2px solid #a5d6a7; /* Lighter green outline/border effect */
         outline-offset: 2px; /* Space between button and outline */
         cursor: pointer;
         transition: all 0.1s ease-in-out; /* Faster transition for button inside hub */
         display: flex; /* Use flex to center text inside */
         justify-content: center;
         align-items: center;
         line-height: 1; /* Adjust line height for vertical centering */
    }

     /* Adjust hover/active for the button inside the hub */
     #spinBtn:hover:not(:disabled) {
         background: radial-gradient(circle, #81c784 0%, #66bb6a 100%);
         outline-color: #c8e6c9;
         /* Keep a slight scale effect if desired, but maybe reduce intensity */
         transform: scale(1.05) !important;
         box-shadow: none !important; /* No box-shadow on button itself */
     }
     #spinBtn:active:not(:disabled) {
          background: radial-gradient(circle, #4caf50 0%, #388e3c 100%);
          outline-color: #a5d6a7;
          transform: scale(0.98) !important;
          box-shadow: none !important;
     }
     #spinBtn:disabled {
         background: linear-gradient(145deg, #666, #444); /* Darker grey gradient */
         outline-color: #777;
         cursor: not-allowed;
         border-bottom-color: #222; /* Very dark border */
         box-shadow: none; transform: none; opacity: 0.6; /* More faded */
         color: #aaa; /* Grey text */
         text-shadow: none; /* No text shadow for disabled */
     }

    /* Styles for the new Buy Spin button */
    #buySpinBtn {
         /* Inherits game-btn styles */
         margin-top: 20px; /* Space below the wheel container */
         background: linear-gradient(145deg, #ffc107, #ffa000); /* Amber */
         border-bottom-color: #ff8f00;
         font-size: 13px; /* Slightly smaller font */
         padding: 12px 24px; /* Adjusted padding */
    }
    #buySpinBtn:hover:not(:disabled) {
        background-image: linear-gradient(145deg, #ffca28, #ffb300);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(255, 193, 7, 0.7); /* Yellow glow */
    }
     #buySpinBtn:disabled {
        background: linear-gradient(145deg, #666, #444);
        cursor: not-allowed;
        border-bottom-color: #222;
        box-shadow: none; transform: none; opacity: 0.6;
        color: #aaa; text-shadow: none;
     }


    .spin-info-text {
        margin-top: 20px; /* Space below wheel container */
        font-size: 0.9em;
        color: #bbb;
        font-family: Arial, sans-serif; /* Keep Arial for this text */
        min-height: 1.2em;
        text-align: center;
        line-height: 1.4; /* Improve readability */
    }

     /* Add a specific style for the countdown text within spin-info-text */
     .spin-info-text .countdown {
         font-family: 'Press Start 2P', cursive; /* Use game font for countdown numbers */
         font-size: 1em; /* Make countdown slightly larger */
         color: #eee; /* Lighter color for countdown */
         text-shadow: 1px 1px 2px #000; /* Shadow for readability */
     }


    .prize-result {
        margin-top: 10px; /* Space below info text */
        font-size: 1.1em; /* Slightly smaller result text */
        color: #ffeb3b; /* Yellow */
        text-shadow: 1px 1px 1px rgba(0,0,0,0.7); /* Slightly less shadow */
        min-height: 1.5em; /* Reserve space */
        text-align: center; /* Center text */
        font-family: 'Press Start 2P', cursive; /* Use game font for result */
        line-height: 1.3;
    }

    /* Animation Keyframe (Applied via JS by setting style.transform) */
    /* @keyframes spin {
        to { transform: rotate(CalculatedAngle); }
    } */

    /* --- Withdrawal Modal Specifics --- */
    /* Styles for the task display in the Redeem form */
     #redeemForm .referralTaskDisplay {
         background: #2a2a2a; /* Dark background */
         border: 1px solid #4f4f4f; /* Subtle border */
         border-radius: 8px;
         padding: 15px;
         margin-bottom: 20px;
         text-align: left;
         font-size: 0.9em;
         line-height: 1.5;
         color: #ccc;
         font-family: Arial, sans-serif;
     }
     #redeemForm .referralTaskDisplay strong {
         color: #eee; /* White for strong text */
     }
     #redeemForm .referralTaskDisplay .status-icon {
         font-size: 1.2em;
         vertical-align: middle;
         margin-left: 5px;
     }
     #redeemForm .referralTaskDisplay.task-complete {
          border-color: #4caf50; /* Green border */
          box-shadow: 0 0 8px rgba(76, 175, 80, 0.4); /* Green glow */
          color: #a5d6a7; /* Lighter green text */
     }
      #redeemForm .referralTaskDisplay.task-complete strong {
         color: #e8f5e9; /* Lighter green for strong */
      }
     #redeemForm .referralTaskDisplay.task-complete .status-icon {
         color: #4caf50; /* Green checkmark */
     }
      #redeemForm .referralTaskDisplay.task-incomplete {
         border-color: #f44336; /* Red border */
         box-shadow: 0 0 8px rgba(244, 67, 54, 0.4); /* Red glow */
         color: #ef9a9a; /* Lighter red text */
      }
      #redeemForm .referralTaskDisplay.task-incomplete strong {
         color: #ffebee; /* Lighter red for strong */
      }
     #redeemForm .referralTaskDisplay.task-incomplete .status-icon {
         color: #f44336; /* Red X */
     }

     /* Styles for redeem option buttons */
     .redeem-option {
        /* Inherits .game-btn styles */
         width: 100%;
         margin: 8px 0; /* Slightly less margin */
         padding: 12px 20px;
         font-size: 14px;
         background: linear-gradient(145deg, #2196f3, #1976d2); /* Default Blue */
         border-bottom-color: #0d47a1;
         transition: all 0.2s ease;
     }
     .redeem-option:hover:not(:disabled) {
         background-image: linear-gradient(145deg, #42a5f5, #1e88e5);
         box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(33, 150, 243, 0.7); /* Blue glow */
     }
     .redeem-option:disabled {
         background: linear-gradient(145deg, #666, #444);
         cursor: not-allowed;
         border-bottom-color: #222;
         box-shadow: none; transform: none; opacity: 0.6;
         color: #aaa; text-shadow: none;
     }
      /* Style for the 10k option when redeemed */
     .redeem-option.redeemed-once {
         background: linear-gradient(145deg, #9e9e9e, #757575); /* Grey */
         border-bottom-color: #424242;
         opacity: 0.8; /* Slightly faded */
     }
      .redeem-option.redeemed-once .one-time-text {
          color: #fff; /* White text */
          font-weight: bold;
      }
      /* Style for available options - Add a highlight? */
     .redeem-option.available-option {
          /* Inherits base and hover styles, but perhaps add a subtle glow/border? */
          /* Let's add a border highlight */
          border: 2px solid #4caf50; /* Green border */
          box-shadow: 0 0 8px rgba(76, 175, 80, 0.4); /* Subtle green glow */
     }


    /* --- End of CSS --- */
  </style>

</head>
<body>
  <!-- Status Message Container -->
  <div id="statusMessageContainer"> <span id="statusMessageText"></span> </div>

  <!-- Audio Elements -->
  <audio id="backgroundAudio" loop> <source src="mines background .mp3" type="audio/mp3"> Your browser does not support the audio element. </audio>
  <audio id="jumpSound"> <source src="gruntjumpland-101soundboards.mp3" type="audio/mp3"> </audio>
  <audio id="coinSound"> <source src="coin-recieved-230517.mp3" type="audio/mp3"> </audio>
  <audio id="gameOverSound"> <source src="game-over-arcade-6435.mp3" type="audio/mp3"> </audio>
   <!-- Added Spin Wheel sounds -->
  <audio id="spinSound"> <source src="spin-sound.mp3" type="audio/mp3"> </audio>
  <audio id="winSound"> <source src="win-sound.mp3" type="audio/mp3"> </audio>


  <!-- Google Sign-in Panel -->
  <div id="googleSignInPanel" style="display: flex;">
      <h2>Welcome Gamer!</h2>
      <button id="googleSignInBtn" class="game-btn">
          <img src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg" alt="Google G Logo"/>
          Sign in with Google
      </button>
      <button id="guestButtonAlt" class="game-btn">Continue as Guest</button>
  </div>

  <!-- Complete Profile Modal -->
  <div id="completeProfileModal" class="modal">
      <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
          <button class="close-btn" id="closeCompleteProfile">×</button> <!-- Added ID for closing -->
          <h2>Complete Your Profile</h2>
          <p>Welcome! Please set your username and optionally enter a referral code.</p>
          <div>
              <label for="profileUsernameInput">Username:</label>
              <input type="text" id="profileUsernameInput" placeholder="Choose a username (min 3 chars)" required />
          </div>
           <div>
              <label for="profileReferralInput">Referral Code (Optional):</label>
              <input type="text" id="profileReferralInput" placeholder="Enter friend's code" />
              <p class="subtle">Enter a code to get a bonus!</p>
          </div>
          <button id="saveProfileBtn" class="game-btn">Save and Play</button>
      </div>
  </div>

  <!-- Game Canvas -->
  <canvas id="gameCanvas" style="display: none;"></canvas>

  <!-- Main Menu -->
  <div id="mainMenu" style="display: none;">
     <button id="settingsBtn" title="Open Settings" style="display: none;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M487.4 315.7l-42.1-24.3c2.8-12.8 4.3-26 4.3-39.4s-1.5-26.6-4.3-39.4l42.1-24.3c9.4-5.4 13.3-17.1 9.4-27.2l-45.3-78.4c-3.9-10.1-14.2-14.8-24.7-11.5l-49.5 19.9c-20.5-16.1-43-29.2-67.2-38.1l-7.5-52.8C309 3.7 300.3-2.5 290.3.1l-90.6 18.5c-10 2.1-17.6 9.9-19.8 19.8l-7.5 52.8c-24.3 8.9-46.8 22-67.2 38.1L54.6 83.1c-10.5-3.3-20.8.4-24.7 11.5L-15.4 172.9c-3.9 10.1-.1 21.8 9.4 27.2l42.1 24.3C73.5 243.3 72 256.4 72 269.9c0 13.5 1.5 26.6 4.3 39.4l-42.1 24.3c-9.4 5.4-13.3 17.1-9.4 27.2l45.3 78.4c3.9 10.1 14.2 14.8 24.7 11.5l49.5-19.9c20.5 16.1 43 29.2 67.2 38.1l7.5 52.8c2 10 10.7 15.3 20.7 12.8l90.6-18.5c10-2.1 17.6 9.9 19.8-19.8l7.5-52.8c24.3-8.9 46.8-22 67.2-38.1l49.5 19.9c10.5 3.3 20.8-.4 24.7-11.5l45.3-78.4c3.9-10.1.1 21.8-9.4-27.2zM256 336c-44.2 0-80-35.8-80-80s35.8-80 80-80c44.2 0 80 35.8 80 80s-35.8 80-80 80z"></path></svg>
     </button>
     <div id="topRightStatus">
         <!-- Coin Box -->
          <div id="coinBox" class="status-box">
              <img src="https://i.imgur.com/PCDgdlS.png" alt="Coin">
              <span id="menuCoinCount">0</span>
          </div>
          <!-- PKR Box -->
           <div id="pkrBox" class="status-box">
               <!-- Use a text label for PKR instead of icon if you don't have one -->
               PKR
               <span id="menuPkrBalance">0</span>
           </div>
     </div>
     <button id="startBtn" class="menu-btn game-btn">Play Now</button>
     <button id="withdrawBtn" class="menu-btn game-btn" style="display: none;">Withdraw Coins</button>
     <button id="inviteFriend" class="menu-btn game-btn" style="display: none;">Invite (0)</button>
     <button id="infoBtn" class="menu-btn game-btn">Game Info</button>
     <!-- REMOVED: Download APK Button -->
      <!-- NEW: Android App Button -->
      <button id="androidAppBtn" class="menu-btn game-btn" style="display: none;">Android App</button>
     <button id="logoutBtn" class="menu-btn game-btn" style="display: none;">Exit</button>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
      <button class="close-btn" id="closeSettings">×</button>
      <h2>Settings</h2>
      <button id="profileBtn" class="game-btn">View Profile</button>
      <button id="toggleSound" class="game-btn">Sound: On</button>
      <button id="withdrawalHistoryBtn" class="game-btn">Withdrawal History</button>
      <button id="customerService" class="game-btn">Customer Service</button>
    </div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal" class="modal">
      <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
          <button class="close-btn" id="closeProfileModal">×</button>
          <h2>Gamer Profile</h2>
          <div id="profileInfo">
              <p><strong>Username:</strong> <span id="profileUsername">...</span></p>
              <p><strong>Email:</strong> <span id="profileEmail">...</span></p>
              <p><strong>Total Coins:</strong> <span id="profileTotalCoins">...</span></p>
               <!-- Added PKR Balance to Profile -->
              <p><strong>PKR Balance:</strong> <span id="profilePkrBalance">...</span></p>
              <p><strong>Referrals:</strong> <span id="profileReferralCount">...</span></p>
              <p><strong>Your Code:</strong> <span id="profileInviteCode">...</span></p>
              <p><strong>Joined:</strong> <span id="profileJoinedDate">...</span></p>
               <!-- Added fields for withdrawal status -->
              <p><strong>10k Redeemed:</strong> <span id="profile10kStatus">...</span></p>
               <p><strong>Dynamic Withdrawals:</strong> <span id="profileDynamicWithdrawals">...</span></p>
               <!-- Added Next Free Spin Time to Profile -->
              <p><strong>Next Free Spin:</strong> <span id="profileNextSpinTime">...</span></p>
              <p><strong>Spins Bought Today:</strong> <span id="profileSpinsBoughtToday">...</span></p> <!-- Added spins bought today -->
          </div>
      </div>
  </div>

  <!-- Invite Modal -->
  <div id="inviteModal" class="modal">
      <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
          <button class="close-btn" id="closeInviteModal">×</button>
          <h2>Invite Friend</h2>
          <div class="section">
              <h3>Your Invite Link</h3>
              <div id="yourInviteLinkDisplay">Generating link...</div>
              <button id="copyInviteCode" class="game-btn">Copy Link</button>
          </div>
          <div class="section">
              <h3>Redeem Invite Code</h3>
              <input type="text" id="redeemCodeInput" placeholder="Enter friend's code" />
              <button id="redeemCodeBtn" class="game-btn">Redeem</button>
          </div>
      </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverMenu" style="display: none;">
      <h2>Game Over</h2>
      <p>Session Coins: <span id="sessionCoinCount">0</span></p>
      <p>Total Coins: <span id="finalTotalCoins">0</span></p>
      <button id="restartBtn" class="menu-btn game-btn">Restart</button>
      <button id="backMenuBtn" class="menu-btn game-btn">Back to Menu</button>
  </div>

  <!-- Withdraw Modal -->
  <div id="withdrawModal" class="modal">
     <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
         <button class="close-btn" id="closeWithdraw">×</button>
         <h2>Redeem Coins</h2>
          <p class="withdraw-info">
              The 10k Coin option is a <strong>one-time</strong> withdrawal.
              <br>Higher tiers require referrals, and each successful withdrawal (above 10k) adds <strong>one more referral</strong> needed for future withdrawals.
          </p>
         <div id="redeemOptions">
             <!-- The 10k option - Added span for styling -->
             <button class="redeem-option" data-coins="10000" data-pkr="100">10k Coins - 100 PKR <span class="one-time-text">(One-Time)</span></button>
             <!-- Other options triggering dynamic referral increase -->
             <button class="redeem-option" data-coins="30000" data-pkr="300">30k Coins - 300 PKR</button>
             <button class="redeem-option" data-coins="50000" data-pkr="500">50k Coins - 500 PKR</button>
             <button class="redeem-option" data-coins="80000" data-pkr="800">80k Coins - 800 PKR</button>
             <button class="redeem-option" data-coins="100000" data-pkr="1000">100k Coins - 1000 PKR</button>
             <button class="redeem-option" data-coins="500000" data-pkr="5000">500k Coins - 5000 PKR</button>
         </div>
         <div id="redeemForm" style="display: none;">
             <h3>Enter Details</h3>
             <!-- Referral Task Display -->
             <div id="referralTaskDisplay" class="">
                <!-- Content dynamically set by JS -->
             </div>
             <!-- End Referral Task Display -->
             <form id="redeemDetailsForm">
                 <div><label for="accountHolderName">Account Name:</label><input type="text" id="accountHolderName" required /></div>
                 <div><label for="accountNumber">Account Number:</label><input type="text" id="accountNumber" required /></div>
                 <div class="payment-options" style="margin-top: 15px;">
                     <label>Method:</label>
                     <label><input type="radio" name="paymentMethod" value="JazzCash" required> JazzCash</label>
                     <label><input type="radio" name="paymentMethod" value="EasyPaisa" required> EasyPaisa</label>
                 </div>
                 <button type="submit" id="redeemSubmitBtn" class="game-btn">Submit Request</button>
             </form>
         </div>
     </div>
  </div>

  <!-- Game Info Modal -->
  <div id="infoModal" class="modal">
    <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
      <button class="close-btn" id="closeInfo">×</button>
      <h2>Game Info</h2>
      <p>Welcome to <strong>Mario Run Earn Real Money</strong>! Run, jump, collect coins, and avoid obstacles.</p>
      <p><strong>Login:</strong> Use your Google Account to Sign in and save your progress.</p>
      <p><strong>Guest Play:</strong> Play for fun without saving coins. Great for practice!</p>
      <p><strong>Bonuses:</strong>
          <br>- Get <strong class="highlight">100 Coins</strong> just for signing up!
          <br>- Invite friends using your unique link (find it in the Invite menu).
          <br>- When your friend signs up using your code, they get an <strong class="highlight">extra 100 Coins</strong> (total 200 start!), and YOU get <strong class="highlight">200 Coins!</strong>
          <br>- Try your luck on the <strong class="highlight">Spin Wheel</strong>! You get one FREE spin every 3 hours! Guest rewards are not saved.
          <br>- You can also buy extra spins for <strong class="highlight">1000 Coins</strong> each (max 10 per day, logged-in users only).
      </p> <!-- Updated info text -->
      <p><strong>Withdrawals:</strong> Redeem your earned coins for real rewards via JazzCash or EasyPaisa. <strong class="highlight">Withdrawals require meeting coin and referral tasks.</strong> The 10k PKR option is one-time. Higher tiers require additional referrals for each successful withdrawal. Check the Withdraw menu for details.</p> <!-- Updated info text -->
      <p><strong>Profile:</strong> Check your stats, email, and invite code in Settings > View Profile.</p>
      <!-- REMOVED INFO ABOUT DOWNLOAD APP -->
    </div>
  </div>

  <!-- Withdrawal History Modal -->
  <div id="withdrawalHistoryModal" class="modal">
    <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50"> <!-- Added Tailwind classes -->
      <button class="close-btn" id="closeHistoryModal">×</button>
      <h2>Withdrawal History</h2>
      <div id="historyList"> <p class="no-history">Loading...</p> </div>
    </div>
  </div>

    <!-- Spin Wheel Modal -->
    <div id="spinWheelModal" class="modal">
        <!-- Added Tailwind classes for styling -->
        <div class="modal-content bg-gray-900 p-6 rounded-xl border-4 border-pink-600 shadow-lg shadow-pink-500/50">
            <button class="close-btn" id="closeSpinWheel">×</button>
            <h2>Spin the Wheel!</h2> <!-- Updated title -->
            <!-- Added Tailwind classes for styling -->
            <div class="spin-wheel-container mx-auto w-72 h-72 bg-gray-800 rounded-full border-4 border-gray-600 shadow-lg">
                <!-- REMOVED: <div class="pointer"></div> -->
                <div class="wheel">
                     <!-- Segments are text containers OVER the spinning background image -->
                     <!-- Segment divs act as containers for text positioning relative to wheel center -->
                     <!-- Text content will be set dynamically by JS -->
                     <!-- Adding 8 segments -->
                     <div class="segment" data-segment-index="0"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="1"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="2"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="3"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="4"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="5"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="6"><div class="prize-text"></div></div>
                     <div class="segment" data-segment-index="7"><div class="prize-text"></div></div>
                </div>
                 <!-- Added the central hub element - Now contains the button -->
                <div class="wheel-hub">
                    <button id="spinBtn" class="game-btn">Spin</button> <!-- MOVED BUTTON INSIDE HUB -->
                </div>

            </div>
            <!-- Spin Info Text and Prize Result below the wheel container -->
            <p class="spin-info-text text-center text-sm text-gray-400 mt-4" id="spinInfoText">Checking spin availability...</p>
            <!-- Added Tailwind classes for styling -->
            <p class="prize-result text-center text-base text-yellow-400 font-bold mt-2" id="spinPrizeResult"></p>

            <!-- NEW: Buy Spin Button -->
            <button id="buySpinBtn" class="game-btn">Buy Spin (1000 Coins)</button>

        </div>
    </div>


  <!-- AD INTEGRATION -->
  <div id="bannerAdContainer">
    <script type="text/javascript">
        atOptions = {
            'key' : '34daa95d37aa866e4d5dc188a42570f8', /* Updated key */
            'format' : 'iframe',
            'height' : 50,
            'width' : 320,
            'params' : {}
        };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/34daa95d37aa866e4d5dc188a42570f8/invoke.js"></script> <!-- Updated key -->
  </div>
  <div id="interstitialAdOverlay" style="display: none;">
      <p id="adInfoText">Loading ad...</p>
      <div id="interstitialAdTimer"></div>
      <button id="interstitialAdCloseButton" class="game-btn">Skip Ad</button>
      <p class="skip-info">(Click 'Skip Ad' or close ad tab manually if needed)</p>
  </div>

    <!-- WhatsApp Button -->
    <a href="https://whatsapp.com/channel/0029VbAKXCi2ER6lhPezY50a" target="_blank" id="whatsappBtn" class="fixed-bottom-btn" title="Join our WhatsApp Channel">
        <img src="https://i.imgur.com/d2UlLQN.png" alt="WhatsApp Icon"> <!-- CORRECTED IMAGE LINK -->
    </a>

    <!-- Spin Wheel Button -->
    <button id="spinWheelBtn" class="fixed-bottom-btn" title="Spin to Win!">
        <!-- Local image path -->
        <img src="./Picsart_25-06-03_14-44-00-310.png" alt="Spin Icon">
    </button>


  <!-- Firebase and Game Scripts -->
  <script type="module">
    // --- Firebase Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-app.js";
    import { getDatabase, ref, set, get, push, query, orderByChild, equalTo, onValue, serverTimestamp, update } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-database.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.3.0/firebase-auth.js";

    // --- DOM Element References ---
    const googleSignInPanel = document.getElementById('googleSignInPanel');
    const googleSignInBtn = document.getElementById('googleSignInBtn');
    const guestButtonAlt = document.getElementById('guestButtonAlt');
    const completeProfileModal = document.getElementById('completeProfileModal');
    const closeCompleteProfileBtn = document.getElementById('closeCompleteProfile'); // Added close button for profile modal
    const profileUsernameInput = document.getElementById('profileUsernameInput');
    const profileReferralInput = document.getElementById('profileReferralInput');
    const saveProfileBtn = document.getElementById('saveProfileBtn');
    const mainMenu = document.getElementById('mainMenu');
    const gameOverMenu = document.getElementById('gameOverMenu');
    const gameCanvas = document.getElementById('gameCanvas');
    const settingsModal = document.getElementById('settingsModal');
    const profileModal = document.getElementById('profileModal');
    const inviteModal = document.getElementById('inviteModal');
    const withdrawModal = document.getElementById('withdrawModal');
    const infoModal = document.getElementById('infoModal');
    const withdrawalHistoryModal = document.getElementById('withdrawalHistoryModal');
    const historyListDiv = document.getElementById('historyList');
    const interstitialAdOverlay = document.getElementById('interstitialAdOverlay');
    const interstitialAdCloseButton = document.getElementById('interstitialAdCloseButton');
    const interstitialAdTimer = document.getElementById('interstitialAdTimer');
    const adInfoText = document.getElementById('adInfoText');
    // --- Updated top-right status display references ---
    const topRightStatus = document.getElementById('topRightStatus');
    const coinBox = document.getElementById('coinBox'); // Added reference for coin box
    const pkrBox = document.getElementById('pkrBox');   // Added reference for PKR box
    const menuCoinCountSpan = document.getElementById('menuCoinCount');
    const menuPkrBalanceSpan = document.getElementById('menuPkrBalance');

    const finalTotalCoinsSpan = document.getElementById('finalTotalCoins');
    const sessionCoinCountSpan = document.getElementById('sessionCoinCount');
    const inviteFriendBtn = document.getElementById('inviteFriend');
    const yourInviteLinkDisplay = document.getElementById('yourInviteLinkDisplay');
    const redeemCodeInput = document.getElementById("redeemCodeInput");
    const toggleSoundBtn = document.getElementById("toggleSound");
    const redeemOptionsDiv = document.getElementById("redeemOptions");
    const redeemFormDiv = document.getElementById("redeemForm");
    const redeemDetailsForm = document.getElementById("redeemDetailsForm");
    const redeemSubmitBtn = document.getElementById('redeemSubmitBtn');
    const withdrawalHistoryBtn = document.getElementById('withdrawalHistoryBtn');
    const closeHistoryModalBtn = document.getElementById('closeHistoryModal');
    const profileBtn = document.getElementById('profileBtn');
    const closeProfileModalBtn = document.getElementById('closeProfileModal');
    const profileUsernameSpan = document.getElementById('profileUsername');
    const profileEmailSpan = document.getElementById('profileEmail');
    const profileTotalCoinsSpan = document.getElementById('profileTotalCoins');
    const profilePkrBalanceSpan = document.getElementById('profilePkrBalance'); // Added reference for PKR Balance in Profile
    const profileReferralCountSpan = document.getElementById('profileReferralCount');
    const profileInviteCodeSpan = document.getElementById('profileInviteCode');
    const profileJoinedDateSpan = document.getElementById('profileJoinedDate');
    const profile10kStatusSpan = document.getElementById('profile10kStatus');
    const profileDynamicWithdrawalsSpan = document.getElementById('profileDynamicWithdrawals');
    const profileNextSpinTimeSpan = document.getElementById('profileNextSpinTime'); // Added reference for next spin time in profile
    const profileSpinsBoughtTodaySpan = document.getElementById('profileSpinsBoughtToday'); // Added reference for spins bought today

    const statusMessageContainer = document.getElementById('statusMessageContainer');
    const statusMessageText = document.getElementById('statusMessageText');
    let statusMessageTimeoutId = null;
    const backgroundAudio = document.getElementById("backgroundAudio");
    const jumpSound = document.getElementById("jumpSound");
    const coinSound = document.getElementById("coinSound");
    const gameOverSound = document.getElementById("gameOverSound"); // Corrected ID
     // Added Spin Wheel sounds
    const spinSound = document.getElementById("spinSound"); // Corrected ID
    const winSound = document.getElementById("winSound"); // Corrected ID

    const settingsBtn = document.getElementById('settingsBtn');
    const closeSettings = document.getElementById('closeSettings');
    const infoBtn = document.getElementById('infoBtn');
    const closeInfo = document.getElementById('closeInfo');
    const copyInviteCode = document.getElementById('copyInviteCode');
    const redeemCodeBtn = document.getElementById('redeemCodeBtn');
    const closeInviteModal = document.getElementById('closeInviteModal');
    const withdrawBtn = document.getElementById('withdrawBtn');
    const closeWithdraw = document.getElementById('closeWithdraw');
    const logoutBtn = document.getElementById('logoutBtn');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const backMenuBtn = document.getElementById('backMenuBtn');
    const customerService = document.getElementById('customerService');
    const accountHolderName = document.getElementById('accountHolderName');
    const accountNumber = document.getElementById('accountNumber');
    const referralTaskDisplay = document.getElementById('referralTaskDisplay');
    const whatsappBtn = document.getElementById('whatsappBtn');
     // Added Spin Wheel DOM references
    const spinWheelBtn = document.getElementById('spinWheelBtn');
    const spinWheelModal = document.getElementById('spinWheelModal');
    const closeSpinWheelBtn = document.getElementById('closeSpinWheel');
    const wheelElement = document.querySelector('#spinWheelModal .wheel');
    const spinBtn = document.getElementById('spinBtn'); // Button is now inside the hub
    const buySpinBtn = document.getElementById('buySpinBtn'); // NEW: Buy Spin button
    const spinPrizeResultSpan = document.getElementById('spinPrizeResult');
    const spinInfoTextSpan = document.getElementById('spinInfoText'); // Added reference for info text
    const wheelSegments = document.querySelectorAll('#spinWheelModal .segment'); // Re-added reference to segments
    const androidAppBtn = document.getElementById('androidAppBtn'); // NEW: Android App button reference


    const firebaseConfig = {
      // --- Your Firebase Config --- // Copied from original
      apiKey: "AIzaSyCpheUGTtliJyTXjVlm1VnfvGTbaeykQ7E", authDomain: "super-mario-earn-real-money.firebaseapp.com",
      databaseURL: "https://super-mario-earn-real-money-default-rtdb.firebaseio.com", projectId: "super-mario-earn-real-money",
      storageBucket: "super-mario-earn-real-money.firebasestorage.app", messagingSenderId: "527750706733",
      appId: "1:527750706733:web:71f31dc125468ca645eaa4", measurementId: "G-Z25ZFF8PWT"
      // --- End Firebase Config --- //
    };

    // --- Firebase Initialization ---
    let appFirebase, db, auth;
    try {
        appFirebase = initializeApp(firebaseConfig);
        db = getDatabase(appFirebase);
        auth = getAuth();
        console.log("Firebase initialized successfully.");
    } catch (error) {
        console.error("Firebase initialization failed:", error);
        showStatusMessage("Connection error. Cannot initialize.", "error", 10000);
        // Keep buttons enabled here so the user can see them, setAuthProcessing will handle disabling on click
        // if (googleSignInBtn) googleSignInBtn.disabled = true;
        // if (guestButtonAlt) guestButtonAlt.disabled = true;
    }

    // --- Global State ---
    let totalCoins = 0, totalPKR = 0, soundEnabled = true, currentUserInviteCode = null, currentUsername = null; // Added totalPKR
    let currentReferralCount = 0, currentJoinedDate = null, gameStarted = false, gameOver = false;
    let hasRedeemed10kOnce = false;
    let successfulDynamicWithdrawals = 0;
    let nextFreeSpinTime = 0; // Timestamp for the next free spin (0 means available)
    let spinCooldownTimer = null; // Interval ID for the countdown timer display
    let spinsBoughtToday = { count: 0, date: "" }; // NEW: Track spins bought today

    let score = 0, mario, obstacles, coins, speed, bgX, platformX;
    let lastJumpInputTime = 0; const doubleJumpWindow = 350; let canDoubleJump = false;
    // Removed allImagesLoaded flag as game starting issue likely not related to asset loading blocking
    let isProcessingAuth = false;
    let userDataListenerUnsubscribe = null; // Renamed listener variable
    let profileCompleteListener = null;

    // --- Constants ---
    const SIGNUP_BONUS = 100;
    const REFERRER_BONUS = 200;
    const REDEEMER_BONUS = 100;
    const SPIN_COST = 0; // Cost for the free spin
    const BUY_SPIN_COST = 1000; // NEW: Cost for a purchased spin
    const DAILY_BUY_LIMIT = 10; // NEW: Daily limit for purchased spins
    const FREE_SPIN_COOLDOWN = 3 * 60 * 60 * 1000; // 3 hours in milliseconds
    const COIN_TO_PKR_RATE = 0.01; // 1000 Coins = 10 PKR => 1 Coin = 0.01 PKR
    const baseInviteUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
    const withdrawalRequirements = { // Coin amount: base required referrals
        10000: 5,
        30000: 10,
        50000: 20,
        80000: 30,
        100000: 40,
        500000: 50
    };
    // Replace with actual download link
    const androidAppDownloadLink = "#"; // Replace with your actual APK download URL


     // Spin Wheel Prizes and Weights (Updated based on user's list and request for higher chance on low values)
     // Segment Index, Corresponding Prize Name, Type, Value, Weight
     // Weights adjusted: significantly increased for 1 PKR & 100 Coins, increased for 5 PKR & 200 Coins, slightly for 10 PKR, decreased for 20 PKR & 500 Coins.
     // Order based on the visual segments in the image (assuming clockwise from top-right)
     const prizesForSegments = [
         { name: "1 PKR", type: "pkr", value: 1, weight: 250 },         // Index 0 (Visual Red, assuming bottom-right in image)
         { name: "100 Coins", type: "coins", value: 100, weight: 250 },   // Index 1 (Visual Red, assuming bottom-left in image)
         { name: "5 PKR", type: "pkr", value: 5, weight: 100 },         // Index 2 (Visual Orange, assuming middle-left in image)
         { name: "200 Coins", type: "coins", value: 200, weight: 100 },  // Index 3 (Visual Teal/Green, assuming top-left in image)
         { name: "50 PKR", type: "pkr", value: 50, weight: 20 },        // Index 4 (Visual Blue, assuming top-middle in image)
         { name: "300 Coins", type: "coins", value: 300, weight: 10 },  // Index 5 (Visual Purple, assuming top-right in image)
         { name: "100 PKR", type: "pkr", value: 100, weight: 5 },       // Index 6 (Visual Pink, assuming middle-right in image)
         { name: "500 Coins", type: "coins", value: 500, weight: 2 }    // Index 7 (Visual Orange, assuming right in image)
     ]; // Total weight = 250+250+100+100+20+10+5+2 = 737

     // Re-mapping prizes to segment indices based on visual order in image
     // Visual Order (approx. clockwise from top, mapping to prizesForSegments index):
     // Blue (pos ~0) -> 10 PKR (Index 4) ? No, this mapping is confusing.
     // Let's assume the *segment divs* in HTML map to the *visual slices* of the image,
     // starting from the slice just right of the pointer (top).
     // Visual Slice Order (Clockwise from Top-Right Slice): Slice 1, Slice 2, ..., Slice 8
     // Let's map JS prize indices (0-7) to these visual slices.
     // prizesForSegments[0] goes in Slice 1, prizesForSegments[1] in Slice 2, etc.
     // Visual Slice 1 (Top-Right): Index 0 (1 PKR)
     // Visual Slice 2 (Right-Middle): Index 1 (100 Coins)
     // Visual Slice 3 (Bottom-Right): Index 2 (5 PKR)
     // Visual Slice 4 (Bottom-Middle): Index 3 (200 Coins)
     // Visual Slice 5 (Bottom-Left): Index 4 (50 PKR)
     // Visual Slice 6 (Left-Middle): Index 5 (300 Coins)
     // Visual Slice 7 (Top-Left): Index 6 (100 PKR)
     // Visual Slice 8 (Top-Middle): Index 7 (500 Coins)
     // This assumes the image is oriented such that Slice 1 is just clockwise of the top pointer.
     // If Slice 1's center is at ~22.5 deg from top (clockwise), then JS index `i` is visually centered at `i * segmentAngle + segmentAngle / 2`.
     // Let's proceed with this assumption for positioning the text.

     const totalSegments = prizesForSegments.length; // Should be 8
     const segmentAngle = 360 / totalSegments; // 360 / 8 = 45 degrees per segment
     const spinDuration = 5000; // milliseconds
     let isSpinning = false;

     // Function to set segment text positions over the spinning image
     function setupWheelSegments() {
         if (!wheelSegments || wheelSegments.length !== totalSegments || !wheelElement) {
              console.error("Wheel segments or element not found, or count mismatch for text overlay.");
              return;
         }

         // Position and rotate the text elements radially
         const wheelSize = wheelElement.offsetWidth; // Assuming wheelElement is the square container
         // Adjust radialDistancePx to control how far the text is from the center
         // Based on the image, the text seems positioned roughly between the hub and the outer edge.
         // The wheel container is 300x300px. Hub is 60x60px. Radius of wheel = 150px. Radius of hub = 30px.
         // Text seems positioned around 90-120px from the center. Let's use ~105px as an average.
         const radialDistancePx = wheelSize * 0.35; // About 35% of 300px = 105px


         wheelSegments.forEach((segmentElement, index) => {
             // Use the actual prize name from the prizesForSegments array
             const prize = prizesForSegments[index];
             const prizeName = prize.name; // Use the actual name here
             const textElement = segmentElement.querySelector('.prize-text');

             if (textElement) {
                 textElement.textContent = prizeName; // Set the text content to the actual prize name

                 // Calculate the angle of the segment's center (from the top, clockwise) where the text should *visually* sit
                 // Assuming segment 0 visual slice is top-right and slices are clockwise.
                 // Slice 1 center is at 22.5 degrees. Slice 2 center is at 67.5 degrees, etc.
                 // So JS index `i`'s corresponding visual slice center is at `i * segmentAngle + segmentAngle / 2` degrees clockwise from the top.
                 const segmentVisualCenterAngleClockwiseFromTop = index * segmentAngle + segmentAngle / 2;

                 // Position the text element's *center* at the wheel's center (top/left 50% + translate -50%).
                 // Then rotate the element around its center by the segment's angle.
                 // Then translate the element radially outwards.
                 // Then rotate the element back to make the text upright.
                 textElement.style.position = 'absolute';
                 textElement.style.top = '50%';
                 textElement.style.left = '50%';
                 textElement.style.transformOrigin = '50% 50%'; // Element's own center as pivot

                 // The combined transform string:
                 // 1. `translate(-50%, -50%)`: Centers the element's pivot point.
                 // 2. `rotate(angle) translate(distance, 0)`: Rotates the coordinate system about the pivot, then translates along that rotated axis. The angle should be `segmentVisualCenterAngleClockwiseFromTop`. The distance is `radialDistancePx`.
                 // 3. `rotate(90deg)`: Rotates the element itself to make the text upright radially.

                 const finalTransform = `translate(-50%, -50%) rotate(${segmentVisualCenterAngleClockwiseFromTop}deg) translate(${radialDistancePx}px, 0px) rotate(90deg)`;

                 textElement.style.transform = finalTransform;
                 // transform-origin remains 50% 50% (element's center)

                 // Ensure text properties match the request (white, bold, simple font, shadow)
                 textElement.style.fontFamily = 'Arial, sans-serif'; // Keep Arial as in image
                 textElement.style.fontSize = '12px'; // Adjust size to fit well
                 textElement.style.color = '#ffffff'; // White text as in the image
                 textElement.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)'; // Add shadow for readability
                 textElement.style.fontWeight = 'bold'; // Make text bold
                 textElement.style.textAlign = 'center'; // Ensure text is centered on its translated point
             }
         });
     }


    // --- Status Message Function ---
    function showStatusMessage(message, type = 'info', duration = 3000) {
        if (statusMessageTimeoutId) { clearTimeout(statusMessageTimeoutId); statusMessageContainer.classList.remove('show'); }
        console.log(`Status [${type}]: ${message}`);
        statusMessageText.textContent = message;
        statusMessageContainer.className = 'statusMessageContainer'; statusMessageContainer.classList.add(type);
        statusMessageContainer.style.display = 'block'; statusMessageContainer.style.top = '15px'; statusMessageContainer.style.transform = 'translateX(-50%) scale(0.9)';
        void statusMessageContainer.offsetWidth; statusMessageContainer.classList.add('show');
        statusMessageTimeoutId = setTimeout(() => {
            statusMessageContainer.classList.remove('show'); statusMessageTimeoutId = null;
            setTimeout(() => { if (!statusMessageContainer.classList.contains('show')) statusMessageContainer.style.display = 'none'; }, 400);
        }, duration);
    }

    // --- AD INTEGRATION ---
    // IMPORTANT: Updated ad key based on previous code snippet
    const directLinkUrl = "https://www.profitableratecpm.com/zi30dfhjnn?key=b78830ea0cb80a28c4b278ee2e122b06"; // Replace with your actual ad URL
    let adCloseTimerInterval; let adCloseTimeout; let currentAdCallback = null;
    function showInterstitialAd(callback) {
         console.log("Attempting to show Interstitial Ad...");
         if (typeof callback !== 'function') { console.error("Invalid ad callback."); return; }
         currentAdCallback = callback; adInfoText.textContent = "Ad loading...";
         interstitialAdOverlay.style.display = 'flex'; interstitialAdCloseButton.style.display = 'none'; interstitialAdTimer.textContent = "";

         // Use a small delay before opening the ad window to ensure the overlay shows
         setTimeout(() => {
             let adWindow = null;
             try {
                 adWindow = window.open(directLinkUrl, '_blank');
                 if (!adWindow) {
                     console.warn("Pop-up blocked.");
                     showStatusMessage("Ad might be blocked. Please allow pop-ups.", "info", 5000);
                     // Proceed with the action even if ad is blocked? Or require ad view?
                     // For now, let's proceed after showing a message about blocking.
                     // The ad display is blocking the action (like showing the menu or starting the game)
                     // The callback must be triggered even if the ad is blocked.
                     interstitialAdOverlay.style.display = 'none'; // Hide the overlay if pop-up is blocked
                     if (currentAdCallback) { console.log("Ad blocked, executing callback."); try { currentAdCallback(); } catch (e) { console.error("Error in ad callback after block:", e); } }
                     currentAdCallback = null; // Clear callback
                     return; // Exit the ad logic
                 }
             } catch (e) {
                 console.error("Error opening ad window:", e);
                 showStatusMessage("Error showing ad. Proceeding.", "info", 5000);
                 interstitialAdOverlay.style.display = 'none'; // Hide overlay on error
                 if (currentAdCallback) { console.log("Error opening ad window, executing callback."); try { currentAdCallback(); } catch (e) { console.error("Error in ad callback after opening error:", e); } }
                 currentAdCallback = null; // Clear callback
                 return; // Exit the ad logic
             }


             // If pop-up was opened successfully (adWindow is not null/undefined), show timer and skip button
             let secondsRemaining = 5; // Start timer for skipping after a few seconds
             interstitialAdTimer.textContent = `Skip in ${secondsRemaining}s`;
             if (adCloseTimerInterval) clearInterval(adCloseTimerInterval);
             if (adCloseTimeout) clearTimeout(adCloseTimeout);

             adCloseTimerInterval = setInterval(() => {
                 secondsRemaining--;
                 if (secondsRemaining > 0) {
                     interstitialAdTimer.textContent = `Skip in ${secondsRemaining}s`;
                 } else {
                     interstitialAdTimer.textContent = "Skip available";
                     clearInterval(adCloseTimerInterval);
                 }
             }, 1000);

             adCloseTimeout = setTimeout(() => {
                 interstitialAdCloseButton.style.display = 'inline-flex'; // Show skip button
                  if (adCloseTimerInterval) clearInterval(adCloseTimerInterval); // Ensure timer text stops updating
                  interstitialAdTimer.textContent = "Skip available"; // Final timer text
             }, 5000); // Show skip button after 5 seconds (adjust as needed)

             // Optional: Add a listener to the ad window closing? Not reliable across browsers.
             // Relying on the skip button or the ad being viewed/closed manually.

         }, 100); // Delay before opening window
    }
    interstitialAdCloseButton.addEventListener('click', () => {
         console.log("Ad Skip Button clicked.");
         interstitialAdOverlay.style.display = 'none';
         if (adCloseTimerInterval) clearInterval(adCloseTimerInterval); if (adCloseTimeout) clearTimeout(adCloseTimeout);
         interstitialAdTimer.textContent = "";
         if (typeof currentAdCallback === 'function') { console.log("Executing ad callback after skip."); try { currentAdCallback(); } catch(e) { console.error("Error in ad callback:", e); showStatusMessage("Error proceeding.", "error"); } currentAdCallback = null; }
         else { console.warn("No ad callback found after skipping."); }
    });

    // --- Sound Functions ---
    function playSound(audioElement) { if (soundEnabled && audioElement) { try { audioElement.currentTime=0; audioElement.play().catch(e=>console.warn(`Sound play error (${audioElement.id}):`, e)); } catch(e) { console.warn("Sound play failed:", e); } } }
    function playBackgroundMusic() { if (soundEnabled && backgroundAudio && backgroundAudio.paused) { backgroundAudio.play().catch(e=>console.warn("Background music play failed:",e)); } }
    function stopBackgroundMusic() { if (backgroundAudio && !backgroundAudio.paused) { backgroundAudio.pause(); backgroundAudio.currentTime=0; } }

    // --- Authentication Logic ---
    function setAuthProcessing(isProcessing) {
        console.log(`Setting Auth Processing: ${isProcessing}`); isProcessingAuth = isProcessing;
        // Disable/enable relevant buttons during auth process
        if(googleSignInBtn) googleSignInBtn.disabled = isProcessing;
        if(guestButtonAlt) guestButtonAlt.disabled = isProcessing;
        if(saveProfileBtn) saveProfileBtn.disabled = isProcessing;
        if(logoutBtn) logoutBtn.disabled = isProcessing;
        // Disable menu buttons if main menu is visible AND auth is processing
        if (mainMenu.style.display === 'flex') {
             document.querySelectorAll('#mainMenu .menu-btn').forEach(btn => btn.disabled = isProcessing);
             // Re-enable specific buttons here if needed after processing, handled by showMainMenu
        } else if (gameOverMenu.style.display === 'flex') {
            // Disable game over buttons if processing
            if(restartBtn) restartBtn.disabled = isProcessing;
            if(backMenuBtn) backMenuBtn.disabled = isProcessing;
        }
         // Spin and Buy Spin button states are managed by updateSpinButtonAndInfo & updateBuySpinButtonState, which consider isSpinning and cooldown, coins, limit, and isProcessingAuth
         // Call these updates *after* setting the global isProcessingAuth flag
         if(spinBtn) updateSpinButtonAndInfo();
         if(buySpinBtn) updateBuySpinButtonState();

         // Fixed bottom buttons might also need disabling
         if (whatsappBtn) whatsappBtn.style.pointerEvents = isProcessing ? 'none' : 'auto';
         if (spinWheelBtn) spinWheelBtn.style.pointerEvents = isProcessing ? 'none' : 'auto'; // Spin wheel button state also depends on processing
    }

    async function handleGoogleSignInSuccess(userCredential) {
        const user = userCredential.user;
        console.log(`Google Sign-In Success for: ${user.uid}. Checking profile...`);
        setAuthProcessing(true); // Set processing true *at the start*

        try {
            const userRef = ref(db, `users/${user.uid}`); const snapshot = await get(userRef);
            if (snapshot.exists() && snapshot.val().username) {
                console.log("Existing user with username found.");
                showStatusMessage(`Welcome back!`, "success", 2000);
                // Use a small timeout before ad to allow status message to show
                setTimeout(() => {
                     showInterstitialAd(async () => { // Ad before showing main menu
                        try {
                            await loadUserData(user.uid); // Loads data and updates local state
                            setupUserDataListener(user.uid); // Start real-time listener
                            checkAndMergeGuestCooldown(user.uid); // Check guest cooldown after login
                             // setAuthProcessing(false); // Moved to after showMainMenu/setAuthProcessing(false) call
                            showMainMenu(); // Show menu *after* ad and data load
                             setAuthProcessing(false); // End auth processing AFTER showing menu and updating buttons
                        } catch (loadError) {
                            console.error("Failed to load user data after ad:", loadError);
                            showStatusMessage("Error loading profile data. Logging out.", "error");
                             setAuthProcessing(false); // End processing on error
                             signOut(auth).catch(e => console.error("Sign out error:", e)); // Log out on critical error
                             // The onAuthStateChanged listener will catch the sign out and show the login screen
                        }
                    });
                }, 500); // Short delay
            } else {
                console.log("New user or profile incomplete.");
                showStatusMessage("Complete your profile.", "info", 3000);
                profileUsernameInput.value = user.displayName || ""; profileReferralInput.value = "";
                const urlParams = new URLSearchParams(window.location.search); const refCode = urlParams.get('ref');
                 if (refCode) { profileReferralInput.value = refCode.trim().toUpperCase(); console.log("Referral code pre-filled."); const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname; window.history.replaceState({path:cleanUrl},'',cleanUrl); }
                completeProfileModal.style.display = "block"; googleSignInPanel.style.display = "none";
                 if(profileCompleteListener) saveProfileBtn.removeEventListener('click', profileCompleteListener); // Remove old listener
                profileCompleteListener = createProfileCompletionHandler(user); saveProfileBtn.addEventListener('click', profileCompleteListener); // Add new listener
                setAuthProcessing(false); // End auth processing after showing modal
            }
        } catch (error) {
            console.error("Error checking user existence after Google Sign-in:", error);
            showStatusMessage("Error verifying profile data.", "error");
            setAuthProcessing(false); // End auth processing
            // Ensure they are signed out if profile check fails after successful auth
             signOut(auth).catch(e => console.error("Sign out error:", e));
             // The onAuthStateChanged listener will catch the sign out and show the login screen
        }
    }

     // Added listener for closing complete profile modal
     if (closeCompleteProfileBtn) {
          closeCompleteProfileBtn.addEventListener('click', () => {
               console.log("Complete profile modal closed.");
               completeProfileModal.style.display = 'none';
               // If user closes the modal without completing profile, they are not fully logged in.
               // They should be redirected back to the sign-in options.
               showStatusMessage("Profile not complete. Please sign in again.", "info", 4000);
               signOut(auth).catch(e => console.error("Sign out error:", e)); // Sign out incomplete user
               // onAuthStateChanged will catch the sign out and show the login screen
          });
     }


    function createProfileCompletionHandler(user) {
        return async () => {
            if (isProcessingAuth) { console.log("Ignoring save profile click while processing."); return; }
            const chosenUsername = profileUsernameInput.value.trim(); const referralCode = profileReferralInput.value.trim().toUpperCase();
            if (chosenUsername.length < 3) { showStatusMessage("Username must be >= 3 chars.", "error"); return; }
             if (!/^[a-zA-Z0-9_]{3,}$/.test(chosenUsername)) { showStatusMessage("Invalid username (letters, numbers, underscore only, min 3).", "error"); return; } // More specific validation

            console.log(`Saving profile for ${user.uid}. User: ${chosenUsername}, Ref: ${referralCode}`);
            setAuthProcessing(true); saveProfileBtn.disabled = true; showStatusMessage("Creating profile...", "info");
            try {
                 // Check if username already exists (simple check, collisions possible but unlikely for small app)
                 const usernameQuery = query(ref(db, 'users'), orderByChild('username'), equalTo(chosenUsername));
                 const usernameSnapshot = await get(usernameQuery);
                 if (usernameSnapshot.exists()) {
                     const existingUid = Object.keys(usernameSnapshot.val())[0];
                     if (existingUid !== user.uid) { // Ensure it's not their own existing (but incomplete) profile
                         showStatusMessage("Username already taken.", "error");
                         setAuthProcessing(false); saveProfileBtn.disabled = false;
                         return; // Stop process
                     }
                 }

                const generatedInviteCode = generateRandomCode(); const creationTime = serverTimestamp();
                 // Added new fields: hasRedeemed10kOnce, successfulDynamicWithdrawals, totalPKR, nextFreeSpinTime, spinsBoughtToday
                const initialUserData = { email: user.email, username: chosenUsername, uid: user.uid, totalCoins: SIGNUP_BONUS, totalPKR: 0, referralCount: 0, referralRedeemed: false, codeRedeemedFrom: null, inviteCode: generatedInviteCode, createdAt: creationTime, provider: 'google', hasRedeemed10kOnce: false, successfulDynamicWithdrawals: 0, nextFreeSpinTime: 0, spinsBoughtToday: { count: 0, date: getCurrentDateString() } }; // New users start with spin available, 0 bought spins today
                console.log(`1: Setting initial data (+${SIGNUP_BONUS} coins, 0 PKR, 0 bought spins today)...`);
                // Use update instead of set to avoid overwriting any existing fields accidentally if user somehow had a partial record
                 await update(ref(db, `users/${user.uid}`), initialUserData);
                console.log("2: Initial DB data updated/set.");
                let referralMessage = ""; let finalCoins = SIGNUP_BONUS;
                if (referralCode) {
                    console.log(`3: Attempting referral: ${referralCode}`);
                    try {
                        // Pass the *just created* initial data for the check
                        // Fetch the referrer's data separately if needed, but redeemInviteCode should handle this
                        const { newCoinsForRedeemer, referrerUid } = await redeemInviteCode(referralCode, user.uid, { ...initialUserData, totalCoins: SIGNUP_BONUS }); // Pass initial coins explicitly
                        console.log("4: Referral success.");
                        finalCoins = newCoinsForRedeemer; // This already includes the signup + redeemer bonus
                        // Update the user's record AGAIN to mark redeemed status and set final coins
                        await update(ref(db, `users/${user.uid}`), {
                            referralRedeemed: true,
                            codeRedeemedFrom: referrerUid,
                            totalCoins: finalCoins // Update coins again explicitly
                        });
                        console.log("5: User record updated with redemption details.");
                        referralMessage = ` +${REDEEMER_BONUS} referral bonus!`;
                        // No need to update currentReferralCount here, loadUserData will fetch it
                    } catch (redeemError) {
                        console.warn("4: Referral error:", redeemError.message);
                        referralMessage = ` (Referral error: ${redeemError.message})`;
                        // Even if referral fails, keep the signup bonus. Ensure the DB reflects the signup bonus.
                        finalCoins = SIGNUP_BONUS;
                         await update(ref(db, `users/${user.uid}`), { totalCoins: finalCoins }); // Re-affirm signup bonus
                    }
                } else {
                    // If no referral code, just ensure the signup bonus is confirmed (already done in initial set/update, but no harm re-affirming)
                     await update(ref(db, `users/${user.uid}`), { totalCoins: SIGNUP_BONUS });
                     finalCoins = SIGNUP_BONUS;
                }
                totalCoins = finalCoins; // Update local state immediately
                totalPKR = 0; // Ensure local state for PKR is correct after creation
                nextFreeSpinTime = 0; // Ensure local state for spin is correct
                spinsBoughtToday = { count: 0, date: getCurrentDateString() }; // Ensure local state for bought spins is correct


                showStatusMessage(`Profile created! +${SIGNUP_BONUS} bonus${referralMessage}`, "success", 6000);
                completeProfileModal.style.display = "none";
                 // Use a small timeout before ad to allow status message to show
                 setTimeout(() => {
                      showInterstitialAd(async () => { // Ad before showing main menu
                         try {
                             await loadUserData(user.uid);
                             setupUserDataListener(user.uid); // Renamed listener
                             checkAndMergeGuestCooldown(user.uid); // Check guest cooldown after profile creation
                             // setAuthProcessing(false); // Moved to after showMainMenu/setAuthProcessing(false) call
                             showMainMenu(); // Show menu *after* ad and data load
                             setAuthProcessing(false); // End auth processing AFTER showing menu and updating buttons
                         } catch (loadError) {
                             console.error("Failed to load data after profile creation/ad:", loadError);
                             showStatusMessage("Error loading profile data.", "error");
                             setAuthProcessing(false); // End processing on error
                              signOut(auth).catch(e => console.error("Sign out error:", e)); // Log out on critical error
                             // onAuthStateChanged will handle showing login screen
                         }
                      });
                 }, 500); // Short delay
            } catch (dbError) {
                console.error("Error saving profile:", dbError); showStatusMessage("Error saving profile.", "error");
                setAuthProcessing(false); saveProfileBtn.disabled = false;
            }
        };
    }

    googleSignInBtn.addEventListener("click", () => {
        if (isProcessingAuth) { console.log("Ignoring Google Sign In click while processing."); return; }
        console.log("Google Sign In clicked."); setAuthProcessing(true); showStatusMessage("Opening Google Sign-in...", "info", 2000);
        const provider = new GoogleAuthProvider();
        // Call Firebase Auth sign-in method
        signInWithPopup(auth, provider)
            .then(handleGoogleSignInSuccess) // Handle successful sign-in and profile check
            .catch((error) => {
                console.error("Google Sign-In Error:", error);
                let errorMsg = "Google Sign-in failed.";
                if (error.code === 'auth/popup-closed-by-user') errorMsg = "Sign-in cancelled by user.";
                else if (error.code === 'auth/network-request-failed') errorMsg = "Network error during sign-in.";
                 else if (error.code === 'auth/cancelled-popup-request') {
                    // This happens if the user clicks the button multiple times quickly
                    // and a previous popup is still open or was just closed. It's common
                    // and often doesn't need a user-facing error message.
                    console.warn("Pop-up request cancelled.");
                    setAuthProcessing(false); // Still need to reset processing flag
                    return; // Exit without showing error message
                 }
                 else if (error.code === 'auth/unauthorized-domain') errorMsg = "Unauthorized domain. Check Firebase settings.";
                 else if (error.code === 'auth/operation-not-allowed') errorMsg = "Google sign-in not enabled in Firebase Auth.";
                 else errorMsg = `Sign-in error: ${error.message}`; // Generic fallback

                showStatusMessage(errorMsg, "error", 5000); // Show informative error
                setAuthProcessing(false); // Reset processing flag
            });
    });


    guestButtonAlt.addEventListener("click", () => {
         if (isProcessingAuth) { console.log("Ignoring Guest click while processing."); return; }
        console.log("Guest button clicked."); setAuthProcessing(true); // Set processing true *on click*
        try {
            googleSignInPanel.style.display = "none";
            resetAppStateToLoggedOut(); // Resets local state, but loads guest cooldown
             // setAuthProcessing(false); // This call is done below after showMainMenu
            showMainMenu(); // This will handle showing/hiding spin button and starting timer display
            showStatusMessage("Playing as Guest.", "info", 4000);
            setAuthProcessing(false); // End processing after synchronous actions
        }
        catch (error) {
            console.error("Error entering guest mode:", error);
            showStatusMessage("Error starting guest mode.", "error");
            googleSignInPanel.style.display = "flex"; // Stay on sign-in page
             setAuthProcessing(false); // Ensure processing is reset on error
        }
    });

     // Helper to get current date string YYYY-MM-DD
     function getCurrentDateString() {
         const today = new Date();
         const year = today.getFullYear();
         const month = String(today.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
         const day = String(today.getDate()).padStart(2, '0');
         return `${year}-${month}-${day}`;
     }

     // --- Real-time User Data Listener Setup (Combined) ---
     // Listens for changes to coins, PKR, referral count, and withdrawal status, spin time, spins bought
    function setupUserDataListener(userId) {
         if (!userId) { console.error("No userId for data listener."); return; }
         if (userDataListenerUnsubscribe) { console.warn("Removing existing data listener."); userDataListenerUnsubscribe(); userDataListenerUnsubscribe = null; }
         const userRefPath = `users/${userId}`;
         const userRef = ref(db, userRefPath);
         console.log(`Setting up user data listener for ${userId}`);
         onValue(userRef, (snapshot) => {
            if (snapshot.exists()) {
                 const userData = snapshot.val();
                 const newCoins = userData.totalCoins ?? 0;
                 const newPKR = userData.totalPKR ?? 0;
                 const newRefCount = userData.referralCount ?? 0;
                 const newHasRedeemed10kOnce = userData.hasRedeemed10kOnce ?? false;
                 const newSuccessfulDynamicWithdrawals = userData.successfulDynamicWithdrawals ?? 0;
                 const newNextFreeSpinTime = userData.nextFreeSpinTime ?? 0; // Get next spin time
                 const newSpinsBoughtToday = userData.spinsBoughtToday ?? { count: 0, date: "" }; // Get spins bought

                 console.log(`RT Data update: Coins=${newCoins}, PKR=${newPKR}, Refs=${newRefCount}, 10kOnce=${newHasRedeemed10kOnce}, DynamicWithdrawals=${newSuccessfulDynamicWithdrawals}, NextSpin=${newNextFreeSpinTime}, SpinsBought=${JSON.stringify(newSpinsBoughtToday)}`);

                 // Update global state only if changed
                 let stateChanged = false;
                 if (totalCoins !== newCoins) { totalCoins = newCoins; stateChanged = true; }
                 if (totalPKR !== newPKR) { totalPKR = newPKR; stateChanged = true; }
                 if (currentReferralCount !== newRefCount) { currentReferralCount = newRefCount; stateChanged = true; }
                 if (hasRedeemed10kOnce !== newHasRedeemed10kOnce) { hasRedeemed10kOnce = newHasRedeemed10kOnce; stateChanged = true; }
                 if (successfulDynamicWithdrawals !== newSuccessfulDynamicWithdrawals) { successfulDynamicWithdrawals = newSuccessfulDynamicWithdrawals; stateChanged = true; }
                 if (nextFreeSpinTime !== newNextFreeSpinTime) { // Check if spin time changed
                      nextFreeSpinTime = newNextFreeSpinTime;
                      stateChanged = true;
                      console.log("Spin time updated from DB:", newNextFreeSpinTime);
                      // startSpinCooldownTimerDisplay() is called by updateSpinButtonAndInfo which is called below
                 }

                 // Handle daily reset for spins bought
                 const todayString = getCurrentDateString();
                 // Check if the date stored in the DB is DIFFERENT from today
                 if (userData.spinsBoughtToday?.date !== todayString) {
                     console.log("Daily reset for spins bought needed.");
                     // Reset local state first
                      spinsBoughtToday = { count: 0, date: todayString };
                      // Then, if user is logged in, trigger a DB update for the reset
                      if (auth.currentUser) { // Double check logged in
                           console.log("Resetting spinsBoughtToday in DB.");
                           // Use update to avoid overwriting the whole node, only update spinsBoughtToday
                           update(ref(db, `users/${userId}`), { spinsBoughtToday: { count: 0, date: todayString } })
                               .catch(e => console.error("Error resetting spinsBoughtToday in DB:", e));
                      }
                 } else {
                     // If dates match, just sync the count from DB to local state
                     spinsBoughtToday = newSpinsBoughtToday; // Sync local state with DB
                 }
                 // Check if spinsBoughtToday state actually changed after potential reset/sync
                 // Simple check: if the string representation of the object changes, the state changed.
                 if (JSON.stringify(spinsBoughtToday) !== JSON.stringify(newSpinsBoughtToday)) {
                      stateChanged = true; // Mark state as changed if spinsBoughtToday was updated
                 }


                 // Update UI if any state changed or if state hasn't changed but UI might be showing (e.g. modal opened)
                 // Always update relevant UI elements just in case, especially balance/refs/spin time/spins bought
                 updateTopRightStatus(); // Update top-right display
                 if (finalTotalCoinsSpan && gameOverMenu.style.display === 'flex') finalTotalCoinsSpan.innerText = totalCoins; // Keep total coins for game over
                 if (profileModal.style.display === 'block') { // Update profile modal if open
                     profileUsernameSpan.textContent = currentUsername || '...'; // Ensure username is shown if loaded
                     profileEmailSpan.textContent = auth.currentUser?.email || 'N/A';
                     profileTotalCoinsSpan.textContent = totalCoins;
                     profilePkrBalanceSpan.textContent = totalPKR;
                     profileReferralCountSpan.textContent = currentReferralCount;
                     profileInviteCodeSpan.textContent = currentUserInviteCode || '...';
                     profileJoinedDateSpan.textContent = currentJoinedDate || '...';
                     profile10kStatusSpan.textContent = hasRedeemed10kOnce ? "Yes" : "No";
                     profileDynamicWithdrawalsSpan.textContent = successfulDynamicWithdrawals;
                     profileNextSpinTimeSpan.textContent = nextFreeSpinTime > Date.now() ? new Date(nextFreeSpinTime).toLocaleString() : 'Available'; // Update profile spin time
                      profileSpinsBoughtTodaySpan.textContent = `${spinsBoughtToday.count}/${DAILY_BUY_LIMIT}`; // Update spins bought display
                 }
                 updateInviteButtonText(currentReferralCount);
                 updateWithdrawalOptionStates(); // Update withdraw buttons
                 updateSpinButtonAndInfo(); // Update free spin button state and info text
                 updateBuySpinButtonState(); // NEW: Update buy spin button state

            } else {
                console.warn(`RT Listener: User node ${userId} no longer exists. Logging out.`);
                if (userDataListenerUnsubscribe) { userDataListenerUnsubscribe(); userDataListenerUnsubscribe = null; }
                signOut(auth).catch(e => console.error("Sign out error on missing node:", e));
            }
         }, (error) => {
             console.error("Firebase user data listener error:", error); showStatusMessage("Data sync error.", "error");
             if (userDataListenerUnsubscribe) { userDataListenerUnsubscribe(); userDataListenerUnsubscribe = null; }
         });
     }

    // --- Handle Guest Cooldown Merge on Login ---
    function checkAndMergeGuestCooldown(userId) {
         try {
              const guestCooldownData = localStorage.getItem('guestSpinCooldown');
             if (guestCooldownData) {
                 const data = JSON.parse(guestCooldownData);
                 const guestNextSpinTime = data.nextFreeSpinTime || 0;

                 // Get current user's next spin time from Firebase (should be loaded already in loadUserData)
                 const userNextSpinTime = nextFreeSpinTime; // Use the value already loaded

                 // Merge if guest cooldown is valid (in future) AND sooner than user's current cooldown
                 if (guestNextSpinTime > Date.now() && (userNextSpinTime === 0 || guestNextSpinTime < userNextSpinTime)) {
                     console.log(`Merging guest cooldown (${new Date(guestNextSpinTime).toISOString()}) for user ${userId}. User had (${userNextSpinTime > 0 ? new Date(userNextSpinTime).toISOString() : 'Available'}).`);
                     // Update user's spin time in DB if guest cooldown is valid (in future) AND sooner than current user time
                      update(ref(db, `users/${userId}`), { nextFreeSpinTime: guestNextSpinTime })
                          .then(() => console.log("Guest cooldown merged successfully."))
                          .catch(e => console.error("Error merging guest cooldown:", e));
                     // The listener will pick up this change and update local state/display
                 } else {
                     console.log("No guest cooldown to merge or user's cooldown is already sooner/expired.");
                 }

                 // Always clear guest cooldown from localStorage after checking/merging
                 localStorage.removeItem('guestSpinCooldown');
             } else {
                  console.log("No guest cooldown found in localStorage.");
             }
         } catch (e) {
             console.error("Error checking or merging guest cooldown:", e);
             localStorage.removeItem('guestSpinCooldown'); // Clear potentially corrupt data
         }
     }


    // --- Reset & Load Data ---
    function resetAppStateToLoggedOut() {
        console.log("Resetting app state to logged-out...");
        if (userDataListenerUnsubscribe) { userDataListenerUnsubscribe(); userDataListenerUnsubscribe = null; } // Stop DB listener
        totalCoins = 0; totalPKR = 0; currentUserInviteCode = null; currentUsername = null; currentReferralCount = 0; currentJoinedDate = null;
        hasRedeemed10kOnce = false;
        successfulDynamicWithdrawals = 0;
        spinsBoughtToday = { count: 0, date: "" }; // Reset bought spins for guest

         // Load the guest cooldown from localStorage when entering guest mode/logging out
         const guestCooldownData = localStorage.getItem('guestSpinCooldown');
         if (guestCooldownData) {
             try {
                  const data = JSON.parse(guestCooldownData);
                  nextFreeSpinTime = data.nextFreeSpinTime || 0;
             } catch (e) {
                 console.error("Error reading guest cooldown on logout reset:", e);
                 localStorage.removeItem('guestSpinCooldown'); // Clear invalid data
                 nextFreeSpinTime = 0;
             }
         } else {
            nextFreeSpinTime = 0; // No guest cooldown found, spin is available
         }


        gameStarted = false; gameOver = false; score = 0; if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
        stopBackgroundMusic();

        // Update UI elements to show logged out state (0s, N/A)
        updateTopRightStatus(); // Update top-right display (will show 0s for guest)
        if (finalTotalCoinsSpan) finalTotalCoinsSpan.innerText = "0"; if (sessionCoinCountSpan) sessionCoinCountSpan.innerText = "0";
        updateInviteButtonText(0); if (yourInviteLinkDisplay) yourInviteLinkDisplay.textContent = "N/A (Log in)";
        if (profileUsernameSpan) profileUsernameSpan.textContent = "..."; if (profileEmailSpan) profileEmailSpan.textContent = "...";
        if (profileTotalCoinsSpan) profileTotalCoinsSpan.textContent = "0";
        if (profilePkrBalanceSpan) profilePkrBalanceSpan.textContent = "0";
        if (profileReferralCountSpan) profileReferralCountSpan.textContent = "0";
        if (profileInviteCodeSpan) profileInviteCodeSpan.textContent = "..."; if (profileJoinedDateSpan) profileJoinedDateSpan.textContent = "...";
        if (profile10kStatusSpan) profile10kStatusSpan.textContent = "...";
        if (profileDynamicWithdrawalsSpan) profileDynamicWithdrawalsSpan.textContent = "...";
        if (profileSpinsBoughtTodaySpan) profileSpinsBoughtTodaySpan.textContent = "..."; // Reset spins bought display
        // profileNextSpinTimeSpan will be updated by startSpinCooldownTimerDisplay


         // Start/Restart the cooldown timer display for guests if a cooldown exists
        startSpinCooldownTimerDisplay();
        updateSpinButtonAndInfo(); // Update free spin button state for guest
        updateBuySpinButtonState(); // Update buy spin button state for guest

        console.log("App state reset complete.");
    }

    function loadUserData(userId) {
       return new Promise((resolve, reject) => {
           if (!userId) {
               console.error("loadUserData: No userId.");
               showStatusMessage("Cannot load data.", "error");
               return reject(new Error("No userId provided"));
           }
           console.log(`Loading data for: ${userId}`);
           const userRef = ref(db, `users/${userId}`);
           get(userRef).then(snapshot => {
               if (snapshot.exists()) {
                   const userData = snapshot.val();
                   console.log("User data fetched:", userData);
                   totalCoins = userData.totalCoins || 0;
                   totalPKR = userData.totalPKR || 0;
                   currentUsername = userData.username || 'Gamer';
                   currentReferralCount = userData.referralCount || 0;
                   currentUserInviteCode = userData.inviteCode;
                   hasRedeemed10kOnce = userData.hasRedeemed10kOnce ?? false;
                   successfulDynamicWithdrawals = userData.successfulDynamicWithdrawals ?? 0;
                    // Load next spin time, use 0 if null/undefined in DB
                   nextFreeSpinTime = userData.nextFreeSpinTime ?? 0;
                    // Load spins bought, handle daily reset on load if needed
                    const todayString = getCurrentDateString();
                    // Check if the date stored in the DB is DIFFERENT from today
                    if (userData.spinsBoughtToday?.date !== todayString) {
                        console.log("Daily reset for spins bought on load.");
                         spinsBoughtToday = { count: 0, date: todayString };
                         // Update DB for reset if logged in and needed
                         if (auth.currentUser) { // Double check logged in
                              console.log("Resetting spinsBoughtToday in DB on load.");
                              // Use update to avoid overwriting the whole node, only update spinsBoughtToday
                              update(ref(db, `users/${userId}`), { spinsBoughtToday: { count: 0, date: todayString } })
                                  .catch(e => console.error("Error resetting spinsBoughtToday in DB on load:", e));
                         }
                    } else {
                         // If dates match, sync the count from DB to local state, ensuring default if node is missing
                         spinsBoughtToday = userData.spinsBoughtToday ?? { count: 0, date: todayString };
                    }


                   if (userData.createdAt) {
                       if (typeof userData.createdAt === 'number') {
                           try { currentJoinedDate = new Date(userData.createdAt).toLocaleDateString(); }
                           catch (e) { console.warn("Error parsing numeric timestamp:", e); currentJoinedDate = "N/A"; }
                       } else if (typeof userData.createdAt === 'object' && userData.createdAt.seconds) {
                           try { currentJoinedDate = new Date(userData.createdAt.seconds * 1000).toLocaleDateString(); }
                           catch (e) { console.warn("Error parsing timestamp object:", e); currentJoinedDate = "N/A"; }
                       } else {
                           console.warn("Unrecognized createdAt format:", userData.createdAt); currentJoinedDate = "N/A";
                       }
                   } else { currentJoinedDate = "N/A"; }

                    // Update UI after loading
                   updateTopRightStatus();
                   updateInviteButtonText(currentReferralCount);
                   updateInviteLinkDisplay();
                   updateWithdrawalOptionStates();
                   startSpinCooldownTimerDisplay(); // Start/update spin cooldown display
                   updateSpinButtonAndInfo(); // Update free spin button state
                   updateBuySpinButtonState(); // NEW: Update buy spin button state


                   if (!currentUserInviteCode && auth.currentUser?.uid === userId) {
                        console.log("Generating invite code...");
                        const newCode = generateRandomCode();
                        set(ref(db, `users/${userId}/inviteCode`), newCode)
                           .then(() => {
                               console.log("New invite code saved:", newCode);
                               currentUserInviteCode = newCode;
                               updateInviteLinkDisplay();
                               if (profileModal.style.display === 'block') profileInviteCodeSpan.textContent = newCode;
                               resolve();
                           })
                           .catch(e => {
                               console.error("Error saving invite code:", e);
                               if(yourInviteLinkDisplay) yourInviteLinkDisplay.textContent = "Error";
                               resolve();
                           });
                   } else {
                       resolve();
                   }
               } else {
                   console.error(`CRITICAL: User node missing: ${userId}. Logging out.`);
                   showStatusMessage("Profile data missing! Logging out.", "error", 5000);
                   signOut(auth).catch(e => console.error("Sign out error on missing node:", e));
                   reject(new Error(`User node missing: ${userId}`));
               }
           }).catch(error => {
               console.error("Error fetching user data:", error);
               showStatusMessage("Failed to load user data.", "error");
               reject(error);
           });
       });
    }

    function checkUrlForReferral() {
        try {
            const urlParams = new URLSearchParams(window.location.search); const refCode = urlParams.get('ref');
            if (refCode) { const cleanCode = refCode.trim().toUpperCase(); console.log("URL Referral code:", cleanCode); if (auth.currentUser && redeemCodeInput) { redeemCodeInput.value = cleanCode; console.log("Referral code pre-filled."); showStatusMessage(`Ready to redeem code: ${cleanCode}?`, "info", 4000); } const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname; window.history.replaceState({path:cleanUrl},'',cleanUrl); console.log("Cleaned URL."); }
        } catch (e) { console.error("Error processing URL params:", e); }
    }

    // --- UI Update & View Navigation ---
    function updateInviteButtonText(count) { inviteFriendBtn.innerText = `Invite (${count || 0} Refs)`; }
    function updateSoundButton() {
        toggleSoundBtn.textContent=`Sound: ${soundEnabled?'On':'Off'}`;
        // Use the correct green/grey theme colors from the updated CSS
        const onGradient="linear-gradient(145deg, #4caf50, #388e3c)";
        const offGradient="linear-gradient(145deg, #9e9e9e, #757575)";
        const onBorder='#1b5e20';
        const offBorder='#424242';
        toggleSoundBtn.style.background=soundEnabled?onGradient:offGradient;
        toggleSoundBtn.style.borderBottomColor=soundEnabled?onBorder:offBorder;
    }
    function updateInviteLinkDisplay() { if (yourInviteLinkDisplay) { if (currentUserInviteCode && auth.currentUser) yourInviteLinkDisplay.textContent = `${baseInviteUrl}?ref=${currentUserInviteCode}`; else if (auth.currentUser) yourInviteLinkDisplay.textContent = "Generating link..."; else yourInviteLinkDisplay.textContent = "Log in to get your invite link"; } if (profileInviteCodeSpan && profileModal.style.display === 'block') profileInviteCodeSpan.textContent = currentUserInviteCode || '...'; }

    // --- Update Top Right Status Display ---
    function updateTopRightStatus() {
        if (!topRightStatus || !coinBox || !pkrBox || !menuCoinCountSpan || !menuPkrBalanceSpan) {
             console.warn("Top right status elements not found.");
            return;
        }
         // Top right status is always shown now for both logged-in and guests
        topRightStatus.style.display = 'inline-flex';

        menuCoinCountSpan.innerText = totalCoins; // Will be 0 for guests (unless you change reset logic)
        menuPkrBalanceSpan.innerText = totalPKR; // Will be 0 for guests (unless you change reset logic)
        // The calculated PKR value is removed from this display as per request
    }


    function showMainMenu() {
        console.log("Showing Main Menu...");
        gameStarted = false; gameOver = false; if (animationFrameId) cancelAnimationFrame(animationFrameId);
        googleSignInPanel.style.display = "none"; completeProfileModal.style.display = 'none'; gameOverMenu.style.display = "none"; gameCanvas.style.display = "none";
        settingsModal.style.display = "none"; profileModal.style.display = "none"; inviteModal.style.display = "none"; withdrawModal.style.display = "none"; infoModal.style.display = "none"; withdrawalHistoryModal.style.display = "none";
        spinWheelModal.style.display = "none"; // Ensure spin wheel modal is hidden
        mainMenu.style.display = "flex";

        // Show WhatsApp and Spin button regardless of login status
        if (whatsappBtn) whatsappBtn.style.display = 'flex';
        if (spinWheelBtn) spinWheelBtn.style.display = 'flex';

         // Update spin button states when showing main menu
         if (spinBtn) updateSpinButtonAndInfo();
         if (buySpinBtn) updateBuySpinButtonState();

        const user = auth.currentUser;
        if (user && currentUsername) {
             console.log("User logged in with complete profile, showing full menu.");
             // Show logged-in specific buttons
             logoutBtn.style.display = 'inline-flex';
             withdrawBtn.style.display = 'inline-flex';
             inviteFriendBtn.style.display = 'inline-flex';
             settingsBtn.style.display = 'flex'; // Settings button is flex
             androidAppBtn.style.display = 'inline-flex'; // Android App button visible for logged-in

             // These are only relevant for logged-in users
             updateInviteButtonText(currentReferralCount);
             updateInviteLinkDisplay();
             updateWithdrawalOptionStates(); // Ensure states are correct when showing menu
        } else {
             console.log("Guest or incomplete profile, showing limited menu.");
             // Hide logged-in features for guest/incomplete
             logoutBtn.style.display = 'none';
             withdrawBtn.style.display = 'none';
             inviteFriendBtn.style.display = 'none';
             settingsBtn.style.display = 'none'; // Settings button hidden for guest
             androidAppBtn.style.display = 'inline-flex'; // Android App button visible for guests too? Let's show it for both. Screenshot doesn't show it, so maybe user wants it logged-in only. Yes, let's show only for logged in per previous request implied by removal.

              // These are relevant but show 0s or N/A for guests
             updateInviteButtonText(0); // Show 0 refs for guests
             updateInviteLinkDisplay(); // Show N/A for invite link for guests
             updateWithdrawalOptionStates(); // This will disable all options for guests (no coins/PKR/profile)
        }

         updateTopRightStatus(); // Always show top right status for both logged-in and guests
         startSpinCooldownTimerDisplay(); // Ensure countdown display starts if needed

        playBackgroundMusic();
        console.log("showMainMenu finished.");
    }


    function showGameOverMenu() {
        console.log("Showing Game Over Menu"); gameStarted = false; gameOver = true;
        sessionCoinCountSpan.innerText = score;
        finalTotalCoinsSpan.innerText = auth.currentUser ? totalCoins : 0; // totalCoins should be updated by listener by now
        gameCanvas.style.display='none';
        gameOverMenu.style.display="flex";
        mainMenu.style.display="none";
         // Hide fixed buttons and status during game over
        if (whatsappBtn) whatsappBtn.style.display = 'none';
        if (spinWheelBtn) spinWheelBtn.style.display = 'none';
        topRightStatus.style.display = 'none';


        stopBackgroundMusic();
        playSound(gameOverSound);
    }


    // --- Spin Wheel Logic ---
    spinWheelBtn.addEventListener("click", () => {
        // Spin Wheel is available for both logged-in and guests
        console.log("Spin Wheel clicked.");
         if (isProcessingAuth) { console.log("Ignoring Spin Wheel click while processing."); return; }


        showInterstitialAd(() => { // Show ad before showing the modal
            console.log("Spin Wheel clicked. Ad shown, showing modal.");
             spinPrizeResultSpan.textContent = ""; // Clear previous result
             spinPrizeResultSpan.style.color = '#ffeb3b'; // Reset result text color
             // Reset wheel rotation for a clean start each time the modal is opened
             if (wheelElement) {
                 wheelElement.style.transition = 'none'; // Remove transition temporarily
                 wheelElement.style.transform = 'rotate(0deg)'; // Reset rotation to 0
             }
             // Setup segment text positions over the image
             setupWheelSegments();

             // Check cooldown and update button state and info text
             updateSpinButtonAndInfo(); // Will check nextFreeSpinTime
             updateBuySpinButtonState(); // NEW: Update buy spin button state

            spinWheelModal.style.display = "block"; // Show the modal
        });
    });

    closeSpinWheelBtn.addEventListener("click", () => {
        spinWheelModal.style.display = "none"; // Close the modal
         spinPrizeResultSpan.textContent = ""; // Clear result on close
         spinPrizeResultSpan.style.color = '#ffeb3b'; // Reset result text color
         if (wheelElement) {
             wheelElement.style.transition = 'none'; // Remove transition temporarily
             wheelElement.style.transform = 'rotate(0deg)'; // Reset rotation on close
         }
         isSpinning = false; // Ensure spinning state is reset if modal is closed manually
         // Cooldown timer display is stopped/cleared in updateSpinButtonAndInfo called by startSpinCooldownTimerDisplay
         // It will restart when Main Menu is shown again.
    });

    // Listeners for both Free Spin and Buy Spin buttons
    spinBtn.addEventListener("click", handleFreeSpin);
    buySpinBtn.addEventListener("click", handleBuySpin); // NEW: Listener for Buy Spin button


     // Updates the Spin button text and disabled state, and the info text
     function updateSpinButtonAndInfo() { // This function now handles the FREE spin button only
        const now = Date.now();
        const timeRemaining = Math.max(0, nextFreeSpinTime - now);
        const isFreeSpinAvailable = timeRemaining <= 0;

        spinBtn.textContent = "Spin"; // Text is always "Spin"

        if (isSpinning) {
            spinBtn.disabled = true;
        } else if (isFreeSpinAvailable) {
            spinBtn.disabled = false;
            // Info text for free spin availability is shown here
            spinInfoTextSpan.innerHTML = `Spins left today: <span class="countdown">1/1</span>`; // Updated info text
            if (spinCooldownTimer) { // If timer was somehow still running, stop it
                 clearInterval(spinCooldownTimer);
                 spinCooldownTimer = null;
            }
        } else {
            // Free spin is on cooldown
            spinBtn.disabled = true; // Disable button

            // Start/Continue countdown display if not already running
            if (!spinCooldownTimer) {
                startSpinCooldownTimerDisplay(); // This function updates spinInfoTextSpan
            }
        }
         // Ensure free spin button is disabled if authentication is processing
         if (isProcessingAuth) {
             spinBtn.disabled = true;
         }
     }

     // NEW: Updates the Buy Spin button text and disabled state
     function updateBuySpinButtonState() {
         const user = auth.currentUser;
         const isLoggedInAndProfileComplete = user && currentUsername;
         const canAfford = totalCoins >= BUY_SPIN_COST;
         const limitNotReached = spinsBoughtToday.count < DAILY_BUY_LIMIT;

         // Buy spin button is only visible and usable if logged in
         if (!isLoggedInAndProfileComplete) {
              buySpinBtn.style.display = 'none'; // Hide for guests
              buySpinBtn.disabled = true;
              buySpinBtn.title = "Log in to buy spins";
              buySpinBtn.textContent = "Buy Spin"; // Reset text
              return;
         } else {
              buySpinBtn.style.display = 'inline-flex'; // Show for logged-in
         }

         if (isSpinning || isProcessingAuth) {
             buySpinBtn.disabled = true;
             buySpinBtn.textContent = "Busy..."; // Or "Spinning..."
             buySpinBtn.title = "Cannot buy while spinning or processing.";
         } else if (!canAfford) {
             buySpinBtn.disabled = true;
             buySpinBtn.textContent = `Buy Spin (${BUY_SPIN_COST} Coins)`;
             buySpinBtn.title = `Need ${BUY_SPIN_COST - totalCoins} more coins.`;
         } else if (!limitNotReached) {
             buySpinBtn.disabled = true;
             buySpinBtn.textContent = "Daily Limit Reached";
             buySpinBtn.title = "You have reached the daily limit for bought spins.";
         } else {
             // Available to buy
             buySpinBtn.disabled = false;
             buySpinBtn.textContent = `Buy Spin (${BUY_SPIN_COST} Coins)`;
             buySpinBtn.title = `Buy ${DAILY_BUY_LIMIT - spinsBoughtToday.count} more today`;
         }
          // Update profile modal display if open
          if (profileModal.style.display === 'block') {
               profileSpinsBoughtTodaySpan.textContent = `${spinsBoughtToday.count}/${DAILY_BUY_LIMIT}`;
          }
     }


     // Starts the Interval timer to update the displayed countdown
     function startSpinCooldownTimerDisplay() {
         // Stop existing timer first
         if (spinCooldownTimer) {
             clearInterval(spinCooldownTimer);
             spinCooldownTimer = null; // Explicitly clear ID
         }

         const now = Date.now();
         const timeRemaining = Math.max(0, nextFreeSpinTime - now);

         if (timeRemaining <= 0) {
             // Cooldown is over, update UI and stop timer (handled by updateSpinButtonAndInfo)
              // Update profile modal if open
             if (profileModal.style.display === 'block') {
                  profileNextSpinTimeSpan.textContent = 'Available';
              }
             // Don't return, let the interval potentially be set up below if timeRemaining > 0
             // but if timeRemaining is 0, updateDisplay() will run once and clear itself.
         }

         // Cooldown is active or just ended, display countdown if > 0
         function updateDisplay() {
             const currentTime = Date.now();
             const remaining = Math.max(0, nextFreeSpinTime - currentTime);

             if (remaining <= 1000) { // Check if less than 1 second remains to avoid awkward 00:00:00 display for too long
                 updateSpinButtonAndInfo(); // Updates button and text to "Spin" (available)
                 // Also update the buy spin button state as free spin timer expiring might affect perception
                 updateBuySpinButtonState(); // ensure buy button state is correct
                 clearInterval(spinCooldownTimer); // Stop the timer
                 spinCooldownTimer = null; // Clear ID
                  // Update profile modal if open
                  if (profileModal.style.display === 'block') {
                       profileNextSpinTimeSpan.textContent = 'Available';
                   }
             } else {
                 const hours = Math.floor(remaining / (1000 * 60 * 60));
                 const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                 const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                 // Updated format to match image style with countdown element
                 spinInfoTextSpan.innerHTML = `Next free spin in: <span class="countdown">${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}</span>`;

                 // Update profile modal if open
                 if (profileModal.style.display === 'block') {
                      profileNextSpinTimeSpan.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                  }
                 // Button state is already handled by updateSpinButtonAndInfo when timer starts
             }
         }

         updateDisplay(); // Update immediately
         // Only set the interval if there's actual time remaining
         if (timeRemaining > 1000) {
            spinCooldownTimer = setInterval(updateDisplay, 1000); // Update every second
         } else {
            // If less than 1 second, a single updateDisplay call is enough, it will handle clearing the timer if it was already set.
            // Ensure timer is null if it's not running
            if (spinCooldownTimer) {
                 clearInterval(spinCooldownTimer);
                 spinCooldownTimer = null;
            }
         }

     }


     // Function to pick a prize based on weights
     function pickPrize(prizes) {
         const prizesToSpin = prizesForSegments; // Use the array with new weights
         const totalWeight = prizesToSpin.reduce((sum, p) => sum + p.weight, 0);

         if (totalWeight <= 0) { // Handle case where no prizes have weight > 0
              console.warn("Total spin weight is zero or less. Cannot pick a prize.");
              return { prize: { name: "No Prize", type: "none", value: 0 }, index: -1 };
         }

         let random = Math.random() * totalWeight;
         console.log("Picking prize. Total weight:", totalWeight, "Random:", random);
         let cumulativeWeight = 0;
         for (let i = 0; i < prizesToSpin.length; i++) {
              const prize = prizesToSpin[i];
              cumulativeWeight += prize.weight; // Add prize weight
             if (random < cumulativeWeight) {
                  console.log("Picked:", prize.name, "Index:", i);
                 return { prize, index: i };
             }
         }

         // Fallback in case of floating point issues, return the last prize
         const lastIndex = prizesToSpin.length - 1;
         console.log("Fallback: Picked last prize:", prizesToSpin[lastIndex].name, "Index:", lastIndex);
         return { prize: prizesToSpin[lastIndex], index: lastIndex };
     }

     // NEW: Shared function to start spin animation and award the prize
     async function startSpinAnimationAndAwardPrize(spinType) { // spinType can be 'free' or 'buy'
        isSpinning = true;
        updateSpinButtonAndInfo(); // Update buttons to disabled/busy state
        updateBuySpinButtonState(); // Update buy button as well

        spinPrizeResultSpan.textContent = "Good luck!"; // Initial text while spinning
        spinPrizeResultSpan.style.color = '#ffeb3b'; // Set color to yellow

        // Pick the prize based on weights *before* animation starts
        const { prize: wonPrize, index: wonSegmentIndex } = pickPrize(prizesForSegments);
        console.log("Prize selected:", wonPrize.name, "Segment Index:", wonSegmentIndex);

         if (wonSegmentIndex === -1) { // Handle "No Prize" fallback
              console.warn("Spin resulted in no prize.");
              // No animation needed for failure? Or play a quick animation? Let's just show result immediately.
              isSpinning = false;
              updateSpinButtonAndInfo();
              updateBuySpinButtonState();
              playSound(gameOverSound); // Or a specific fail sound
              spinPrizeResultSpan.textContent = "No Prize This Time!";
              spinPrizeResultSpan.style.color = '#f44336'; // Red color
              setAuthProcessing(false); // Reset processing after immediate failure
              return; // Stop here
         }


        // Calculate rotation angle for the wheel image to stop at the won segment
        // The pointer is at the top (0 degrees).
        // We need to rotate the wheel container (with the image background and static text)
        // such that the winning segment's visual center aligns with the top pointer.
        // Assuming the image is oriented such that Segment 0 (1 PKR, JS Index 0) is the visual slice
        // just clockwise of the top pointer.
        // Visual Slice Order (Clockwise from Top-Right Slice): Index 0, Index 1, ..., Index 7.
        // Visual Slice 1 (Top-Right) corresponds to JS Index 0. Its center is at ~22.5 degrees clockwise from top.
        // Visual Slice `i`'s center is at `i * segmentAngle + segmentAngle / 2` degrees clockwise from top.
        // To bring the center of Visual Slice `wonSegmentIndex` to the top pointer (0 degrees),
        // the wheel container needs to rotate *counter-clockwise* by `wonSegmentIndex * segmentAngle + segmentAngle / 2` degrees.
        const targetVisualCenterAngleClockwise = wonSegmentIndex * segmentAngle + segmentAngle / 2;

        // Add multiple full counter-clockwise turns for animation effect.
        const baseRotationTurns = 10; // Number of full spins
        const baseRotationDegrees = baseRotationTurns * 360;

        // Add a small random offset *within the visual segment* to make stops slightly unpredictable.
        // We want the pointer to land somewhere within the winning segment's area.
        // Random offset should be between -segmentAngle/2 and +segmentAngle/2. Let's use a slightly smaller range like +/- segmentAngle * 0.4.
        const randomOffsetWithinSegment = (Math.random() - 0.5) * (segmentAngle * 0.8); // Random offset

        // The final rotation angle applied to the wheel container (counter-clockwise)
        // It needs to rotate by base turns + the angle to bring the START of segment 0 (visual)
        // to the pointer (0) + the angle from the start of segment 0 to the start of the winning segment + random offset within the segment.
        // Revisit the visual center mapping. If Segment 0's *visual center* is at `targetVisualCenterAngleClockwise` from the top (clockwise),
        // rotating the wheel *counter-clockwise* by `targetVisualCenterAngleClockwise` will bring its center to the top.
        // Final rotation = -(base turns * 360) - (target visual center angle) - (random offset)
        // The random offset should be applied relative to the segment's center, so add it to the target angle.
        const finalRotationDegrees = -(baseRotationDegrees + targetVisualCenterAngleClockwise + randomOffsetWithinSegment);


         console.log(`Target segment: ${wonSegmentIndex} (${prizesForSegments[wonSegmentIndex].name}), Target Visual Center Angle (Top Clockwise): ${targetVisualCenterAngleClockwise}deg, Random Offset: ${randomOffsetWithinSegment}deg, Final Rotation (Counter-clockwise): ${finalRotationDegrees}deg`);


        // Apply rotation and transition
        if (wheelElement) {
             wheelElement.style.transition = `transform ${spinDuration / 1000}s cubic-bezier(0.25, 0.1, 0.25, 1)`; // Apply transition
             wheelElement.style.transform = `rotate(${finalRotationDegrees}deg)`; // Start spinning
        } else {
             console.error("Wheel element not found during spin animation.");
             // Recover state
             isSpinning = false;
             updateSpinButtonAndInfo();
             updateBuySpinButtonState();
             spinPrizeResultSpan.textContent = "Spin failed.";
             spinPrizeResultSpan.style.color = '#f44336';
             setAuthProcessing(false); // Reset processing after immediate failure
             return;
        }

        playSound(spinSound); // Play spin sound


        // Wait for the animation to finish
         let transitionEndHandler = async function handleSpinEnd() {
             if (wheelElement) {
                wheelElement.removeEventListener('transitionend', transitionEndHandler); // Remove listener
             }
             isSpinning = false;
             updateSpinButtonAndInfo(); // Update button state based on new cooldown
             updateBuySpinButtonState(); // Update buy button state
             playSound(winSound); // Play win sound

            // Award the prize (only save to DB if logged in, update local state always)
            let prizeMessage = "";
            const user = auth.currentUser;
            const isGuest = !user;
            const updates = {}; // Prepare updates for DB for logged-in user

             if (wonPrize.type === 'coins') {
                 totalCoins += wonPrize.value; // Update local state
                 prizeMessage = `You won ${wonPrize.value} Coins!`;
                 console.log("Awarding Coins:", wonPrize.value);
                 if (!isGuest) {
                      // Prepare DB update for awarded coins if logged in
                      updates[`users/${user.uid}/totalCoins`] = totalCoins; // Send the new local total
                 }
                 updateTopRightStatus(); // Update UI immediately
            } else if (wonPrize.type === 'pkr') {
                 totalPKR += wonPrize.value; // Update local state
                 prizeMessage = `You won ${wonPrize.value} PKR!`;
                 console.log("Awarding PKR:", wonPrize.value);
                 if (!isGuest) {
                      // Prepare DB update for awarded PKR if logged in
                      updates[`users/${user.uid}/totalPKR`] = totalPKR; // Send the new local total
                 }
                updateTopRightStatus(); // Update UI immediately
            } else { // Handle potential "none" type or fallback prize
                 prizeMessage = wonPrize.name; // Display "No Prize" or other name
                 console.log("Awarded non-coin/pkr prize:", wonPrize.name);
            }

            // Additional DB update based on spin type if logged in
            if (!isGuest) {
                 if (spinType === 'free') {
                      // The nextFreeSpinTime was already updated in handleFreeSpin and saved to DB
                      // Nothing more to add to updates here for free spin.
                 } else if (spinType === 'buy') {
                      // The totalCoins deduction and spinsBoughtToday update was already done in handleBuySpin and saved to DB
                      // Nothing more to add to updates here for bought spin.
                 }
            } else { // Guest spin - local state updated, but not saved
                 console.log("Guest spin complete. Prize and cooldown updated locally (not saved to DB).");
                 // For guest spins, no DB updates needed.
            }


             // Perform the aggregated DB update if logged in (only if there were updates to make, and not updating root directly)
            if (!isGuest && Object.keys(updates).length > 0) {
                 // Using update on `ref(db)` allows updating multiple paths.
                 // Example: updates = { 'users/uid/totalCoins': X, 'users/uid/totalPKR': Y }
                 try {
                      await update(ref(db), updates);
                      console.log(`Awarded prize saved to DB.`);
                      // The RTDB listener will sync the final state back anyway, including spinsBoughtToday from handleBuySpin
                 } catch (dbError) {
                     console.error("Error saving awarded prize:", dbError);
                     showStatusMessage("Error saving prize! Contact support.", "error", 5000);
                     // Consider if you need to revert local state on DB save failure
                 }
             }


            spinPrizeResultSpan.textContent = prizeMessage; // Display the final result
            // Set color based on prize type or win/loss
            if (wonPrize.type === 'pkr' || wonPrize.type === 'coins') {
                 spinPrizeResultSpan.style.color = '#66bb6a'; // Green for win
            } else {
                 spinPrizeResultSpan.style.color = '#f44336'; // Red for no prize / other
            }

            // Reset the wheel's transition after animation ends, so it's ready for the next spin without animating back to 0 first
             setTimeout(() => { // Use a tiny timeout to ensure the transitionend event finishes
                  if (wheelElement) {
                      wheelElement.style.transition = 'none';
                  }
             }, 50); // Small delay

             // Reset processing flag after everything is done
             setAuthProcessing(false);

         };
         // Add the event listener to the wheel element
         if (wheelElement) {
             wheelElement.addEventListener('transitionend', transitionEndHandler, { once: true }); // Use { once: true } for automatic removal
         } else {
              console.error("Wheel element not found when trying to attach transitionend listener.");
              // Need to manually call the 'end' logic if the animation won't complete
              handleSpinEnd(); // Call the logic directly if no animation possible
         }

     }

    // NEW: Handle Free Spin click
    async function handleFreeSpin() {
        if (isSpinning || isProcessingAuth) { console.log("Ignoring Free Spin click while spinning or processing."); return; }

        const now = Date.now();
        const isFreeSpinAvailable = nextFreeSpinTime <= now;

        if (!isFreeSpinAvailable) {
             showStatusMessage("Next free spin is not ready yet.", "info", 3000);
             updateSpinButtonAndInfo(); // Refresh display
             return;
        }

         // Free spin is available
         console.log("Free spin clicked. Availability OK.");
         setAuthProcessing(true); // Set processing true *before* ad

         // --- Start Cooldown Timer & Update Storage ---
         // Cooldown starts immediately upon *using* the spin (before ad/animation)
        const newNextFreeSpinTime = Date.now() + FREE_SPIN_COOLDOWN; // Use Date.now() again here
        nextFreeSpinTime = newNextFreeSpinTime; // Update local state (will be synced by listener too)

         const user = auth.currentUser;
         const isGuest = !user;

         if (!isGuest) { // Only update DB for logged-in users
              // Update logged-in user's next spin time in Firebase atomically
              // This is done *before* the ad/animation sequence starts.
              update(ref(db, `users/${user.uid}`), { nextFreeSpinTime: newNextFreeSpinTime }) // Use newNextFreeSpinTime here
                  .then(() => console.log("User free spin cooldown updated in DB:", newNextFreeSpinTime))
                  .catch(e => console.error("Error updating user free spin cooldown:", e));
              // The RTDB listener will sync nextFreeSpinTime back, but we updated local state anyway
         } else {
             // Guest: Save guest cooldown to localStorage
             try {
                 localStorage.setItem('guestSpinCooldown', JSON.stringify({ nextFreeSpinTime: nextFreeSpinTime }));
                 console.log("Guest spin cooldown saved to localStorage:", nextFreeSpinTime);
             } catch (e) {
                 console.error("Error saving guest cooldown to localStorage:", e);
                 // Continue without saving, user will lose cooldown on refresh
             }
         }

         // Start countdown display immediately (it reads the updated nextFreeSpinTime)
         startSpinCooldownTimerDisplay();

         // Proceed to ad then animation/prize awarding
        showInterstitialAd(() => {
             console.log("Free spin ad shown. Starting animation and awarding prize.");
             startSpinAnimationAndAwardPrize('free'); // Pass type 'free'
             // setAuthProcessing(false) will be called inside startSpinAnimationAndAwardPrize -> handleSpinEnd
        });
    }

    // NEW: Handle Buy Spin click
    async function handleBuySpin() {
         if (isSpinning || isProcessingAuth) { console.log("Ignoring Buy Spin click while spinning or processing."); return; }

         const user = auth.currentUser;
         if (!user || !currentUsername) {
              showStatusMessage("Log in to buy spins.", "error", 3000);
              updateBuySpinButtonState(); // Refresh display
              return;
         }

         const canAfford = totalCoins >= BUY_SPIN_COST;
         const limitNotReached = spinsBoughtToday.count < DAILY_BUY_LIMIT;

         if (!canAfford) {
             showStatusMessage(`Need ${BUY_SPIN_COST - totalCoins} more coins to buy a spin.`, "error", 3000);
             updateBuySpinButtonState(); // Refresh display
             return;
         }
         if (!limitNotReached) {
              showStatusMessage(`You have reached the daily limit of ${DAILY_BUY_LIMIT} bought spins.`, "info", 3000);
              updateBuySpinButtonState(); // Refresh display
              return;
         }

         // Buy spin is available
         console.log("Buy spin clicked. Checks OK.");
         setAuthProcessing(true); // Set processing true *before* ad

         // Show ad before deducting coins and starting spin
         showInterstitialAd(async () => {
              console.log("Buy spin ad shown. Deducting coins and starting spin process.");

              const userRef = ref(db, `users/${user.uid}`);
              const todayString = getCurrentDateString();

              // Use a transaction or check-and-update approach to ensure atomicity for spinsBoughtToday count
              // Using `update` with the latest *local* state synced by the listener is generally sufficient
              // for simple counters like this, assuming minimal concurrent writes.
              const updatedSpinsBoughtCount = spinsBoughtToday.date === todayString ? spinsBoughtToday.count + 1 : 1; // Calculate new count based on synced state

              const updates = {};
              updates['/totalCoins'] = totalCoins - BUY_SPIN_COST; // Deduct cost from current total (synced)
              updates['/spinsBoughtToday'] = { // Update count and date based on calculated new state
                   count: updatedSpinsBoughtCount,
                   date: todayString
              };

              try {
                  await update(userRef, updates);
                  console.log(`Coins deducted (${BUY_SPIN_COST}). Spins bought incremented to ${updatedSpinsBoughtCount}.`);
                  // Local state totalCoins and spinsBoughtToday will be updated by the RTDB listener shortly.
                  // Start animation and award prize *after* successful deduction.
                  startSpinAnimationAndAwardPrize('buy'); // Pass type 'buy'
                   // setAuthProcessing(false) will be called inside startSpinAnimationAndAwardPrize -> handleSpinEnd

              } catch (dbError) {
                  console.error("Error deducting coins or updating spinsBoughtToday:", dbError);
                  showStatusMessage("Error buying spin. Please try again.", "error", 5000);
                   // If DB update failed, the local state might be incorrect until the listener syncs.
                   // Ensure spinning flag is reset and buttons are re-enabled.
                  isSpinning = false;
                  updateSpinButtonAndInfo();
                  updateBuySpinButtonState();
                  setAuthProcessing(false); // Reset processing
              }
         });
    }


    // --- Settings & Profile Modals ---
    settingsBtn.addEventListener("click", () => {
        if (!auth.currentUser || !currentUsername) { showStatusMessage("Log in & complete profile.", "info"); return; }
         if (isProcessingAuth) { console.log("Ignoring Settings click while processing."); return; }

         showInterstitialAd(() => { // Show ad before opening settings
            console.log("Settings clicked. Ad shown, showing modal.");
            updateSoundButton();
             // Update profile modal content before showing (data comes from synced local state)
             profileUsernameSpan.textContent = currentUsername || '...';
             profileEmailSpan.textContent = auth.currentUser?.email || 'N/A';
             profileTotalCoinsSpan.textContent = totalCoins;
             profilePkrBalanceSpan.textContent = totalPKR;
             profileReferralCountSpan.textContent = currentReferralCount;
             profileInviteCodeSpan.textContent = currentUserInviteCode || '...';
             profileJoinedDateSpan.textContent = currentJoinedDate || '...';
             profile10kStatusSpan.textContent = hasRedeemed10kOnce ? "Yes" : "No";
             profileDynamicWithdrawalsSpan.textContent = successfulDynamicWithdrawals;
             profileNextSpinTimeSpan.textContent = nextFreeSpinTime > Date.now() ? new Date(nextFreeSpinTime).toLocaleString() : 'Available'; // Update profile spin time
             profileSpinsBoughtTodaySpan.textContent = `${spinsBoughtToday.count}/${DAILY_BUY_LIMIT}`; // Update spins bought display


            settingsModal.style.display = "block";
         });
    });
    closeSettings.addEventListener("click", () => { settingsModal.style.display = "none"; });
    toggleSoundBtn.addEventListener("click", () => { soundEnabled = !soundEnabled; updateSoundButton(); if (!soundEnabled) stopBackgroundMusic(); else if (mainMenu.style.display==='flex'||(gameStarted&&!gameOver)) playBackgroundMusic(); showStatusMessage(`Sound ${soundEnabled ? 'On' : 'Off'}`, 'info', 1500); });
    customerService.addEventListener("click", () => { window.open("https://wa.me/923019022815", "_blank"); });
    profileBtn.addEventListener('click', () => {
        const user = auth.currentUser;
         if (!user || !currentUsername) { showStatusMessage("Log in & complete profile.", "error"); return; }
         if (isProcessingAuth) { console.log("Ignoring Profile click while processing."); return; }

         showInterstitialAd(() => { // Show ad before opening profile
             console.log("Profile clicked. Ad shown, showing modal.");
             // Update profile spans before showing modal (data comes from synced local state)
             profileUsernameSpan.textContent = currentUsername || '...';
             profileEmailSpan.textContent = auth.currentUser?.email || 'N/A';
             profileTotalCoinsSpan.textContent = totalCoins;
             profilePkrBalanceSpan.textContent = totalPKR;
             profileReferralCountSpan.textContent = currentReferralCount;
             profileInviteCodeSpan.textContent = currentUserInviteCode || '...';
             profileJoinedDateSpan.textContent = currentJoinedDate || '...';
             profile10kStatusSpan.textContent = hasRedeemed10kOnce ? "Yes" : "No";
             profileDynamicWithdrawalsSpan.textContent = successfulDynamicWithdrawals;
             profileNextSpinTimeSpan.textContent = nextFreeSpinTime > Date.now() ? new Date(nextFreeSpinTime).toLocaleString() : 'Available'; // Update profile spin time
             profileSpinsBoughtTodaySpan.textContent = `${spinsBoughtToday.count}/${DAILY_BUY_LIMIT}`; // Update spins bought display


             settingsModal.style.display = 'none'; // Close settings modal
             profileModal.style.display = 'block'; // Show profile modal
         });
    });
    closeProfileModalBtn.addEventListener('click', () => { profileModal.style.display = 'none'; });
    // Simplified showProfileModal - the ad wrapper handles the display logic and data population now


    // --- Withdrawal History ---
    withdrawalHistoryBtn.addEventListener('click', () => {
         const user = auth.currentUser;
         if (!user) { showStatusMessage("Log in first.", "error"); return; }
         if (isProcessingAuth) { console.log("Ignoring Withdrawal History click while processing."); return; }

         showInterstitialAd(() => { // Show ad before opening history
             console.log("Withdrawal History clicked. Ad shown, showing modal.");
             showWithdrawalHistory(); // This function now only fetches and displays
         });
    });
    closeHistoryModalBtn.addEventListener('click', () => { withdrawalHistoryModal.style.display = 'none'; });

     // showWithdrawalHistory now just fetches and displays, display is handled by the ad callback wrapper
    async function showWithdrawalHistory() {
        const user = auth.currentUser;
        if (!user) { showStatusMessage("Log in first.", "error"); return; }
        if (!historyListDiv) { console.error("History list div not found."); return; }

        historyListDiv.innerHTML = '<p class="no-history">Loading...</p>'; // Show loading state
        withdrawalHistoryModal.style.display = 'block'; // Show the modal

        try {
            // Fetch withdrawal requests for the current user, ordered by timestamp descending
            const requestsRef = ref(db, 'withdrawRequests');
            // Cannot easily order by timestamp directly with equalTo on uid without an index.
            // Let's fetch all and filter client-side for simplicity, assuming number of requests per user isn't massive.
            // A proper solution would require a composite index or a different data structure.
            const snapshot = await get(query(requestsRef, orderByChild('uid'), equalTo(user.uid)));

            if (snapshot.exists()) {
                const historyData = snapshot.val();
                const historyItems = Object.keys(historyData).map(key => ({ id: key, ...historyData[key] }));

                // Sort by timestamp descending (newest first)
                historyItems.sort((a, b) => {
                     // Handle serverTimestamp objects or numbers
                    const timestampA = a.timestamp && typeof a.timestamp === 'object' && a.timestamp.seconds !== undefined ? a.timestamp.seconds * 1000 : a.timestamp || (a.timestamp ?? 0); // Handle null/undefined timestamps
                    const timestampB = b.timestamp && typeof b.timestamp === 'object' && b.timestamp.seconds !== undefined ? b.timestamp.seconds * 10ajustada : b.timestamp || (b.timestamp ?? 0); // Corrected: Use a non-zero default
                     return timestampB - timestampA; // Descending sort
                });

                historyListDiv.innerHTML = ''; // Clear loading message

                if (historyItems.length === 0) {
                     historyListDiv.innerHTML = '<p class="no-history">No withdrawal history yet.</p>';
                } else {
                    historyItems.forEach(item => {
                        const statusClass = `status-${item.status}`;
                        const date = item.timestamp ? new Date(item.timestamp).toLocaleString() : 'N/A';
                        const itemHtml = `
                            <div class="history-item">
                                <div class="details">
                                    <span>${item.withdrawalAmountCoins} Coins (${item.pkrAmount} PKR)</span>
                                    <span>Method: ${item.paymentMethod}</span>
                                    <span>Account: ${item.accountNumber}</span>
                                </div>
                                <span class="status ${statusClass}">${item.status}</span>
                                <span class="date">${date}</span>
                            </div>
                        `;
                        historyListDiv.innerHTML += itemHtml;
                    });
                }
            } else {
                historyListDiv.innerHTML = '<p class="no-history">No withdrawal history yet.</p>';
            }
        } catch (error) {
            console.error("Error fetching withdrawal history:", error);
            historyListDiv.innerHTML = '<p class="no-history">Failed to load history.</p>';
            showStatusMessage("Failed to load history.", "error");
        }
    }


    // --- Invite Logic ---
    inviteFriendBtn.addEventListener("click", () => {
         if (!auth.currentUser || !currentUsername) { showStatusMessage("Log in & complete profile.", "error"); return; }
         if (isProcessingAuth) { console.log("Ignoring Invite click while processing."); return; }

         showInterstitialAd(() => { // Show ad before opening invite modal
              console.log("Invite clicked. Ad shown, showing modal.");
              updateInviteLinkDisplay();
              inviteModal.style.display = "block";
         });
     });
    closeInviteModal.addEventListener("click", () => { inviteModal.style.display = "none"; });

    copyInviteCode.addEventListener("click", () => {
         const link = yourInviteLinkDisplay.textContent;
         if (link && link.startsWith('http') && currentUserInviteCode) {
              // No ad needed for simple copy action
              navigator.clipboard.writeText(link).then(() => showStatusMessage("Link copied!", "success")).catch(err => { showStatusMessage("Failed to copy.", "error"); console.error('Copy error:', err); try { const r=document.createRange(); r.selectNodeContents(yourInviteLinkDisplay); const s=window.getSelection(); s.removeAllRanges(); s.addRange(r); showStatusMessage("Link selected.", "info", 4000); } catch (e) { console.error("Select fallback fail:", e); } });
         } else { showStatusMessage("Link not ready.", "error"); console.warn("Invalid link copy attempt:", link); }
    });

    redeemCodeBtn.addEventListener("click", async () => {
         const code = redeemCodeInput.value.trim().toUpperCase();
         if (!code) { showStatusMessage("Enter code.", "error"); return; }
         const user = auth.currentUser;
         if (!user || !currentUsername) { showStatusMessage("Log in & complete profile.", "error"); return; }
         if (isProcessingAuth) { console.log("Ignoring Redeem click while processing."); return; }


         showInterstitialAd(() => { // Show ad before attempting redemption
             console.log("Redeem Code clicked. Ad shown, attempting redemption.");
              // Moved redemption logic inside the ad callback
             redeemCodeBtn.disabled = true; // Disable button during processing
             setAuthProcessing(true); showStatusMessage("Redeeming...", "info"); // Set processing
             const userRef = ref(db, `users/${user.uid}`);
             get(userRef).then(snap => {
                  if (!snap.exists()) throw new Error("User data not found.");
                  const userData = snap.val();
                  return redeemInviteCode(code, user.uid, userData); // This function now handles the update
             })
             .then(({ newCoinsForRedeemer, referrerUid }) => {
                  console.log(`User ${user.uid} redeemed from ${referrerUid}`);
                  showStatusMessage(`Code redeemed! +${REDEEMER_BONUS} coins.`, "success", 5000);
                  inviteModal.style.display = "none"; redeemCodeInput.value = "";
             })
             .catch(e => {
                  console.error("Redeem error:", e);
                  showStatusMessage(`Error: ${e.message}`, "error", 4000);
             })
             .finally(() => {
                  redeemCodeBtn.disabled = false; // Re-enable button
                  setAuthProcessing(false); // Reset processing
             });
         });
     });

    // --- Redeem Invite Code Function ---
    async function redeemInviteCode(redeemCode, redeemerUid, redeemerData) {
        console.log(`redeemInviteCode: Code=${redeemCode}, Redeemer=${redeemerUid}`);

        if (redeemerData.referralRedeemed) {
            throw new Error("Code already redeemed.");
        }
        if (redeemerData.inviteCode === redeemCode) {
             throw new Error("Cannot redeem your own code.");
        }

        // Find the referrer user by their invite code
        const usersRef = ref(db, 'users');
        const referrerQuery = query(usersRef, orderByChild('inviteCode'), equalTo(redeemCode));
        const referrerSnapshot = await get(referrerQuery);

        if (!referrerSnapshot.exists()) {
            throw new Error("Invalid referral code.");
        }

        const referrerUid = Object.keys(referrerSnapshot.val())[0];
        const referrerData = referrerSnapshot.val()[referrerUid];

        if (referrerUid === redeemerUid) {
             throw new Error("Cannot redeem your own code."); // Double check this case
        }


        // --- Perform the atomic update ---
        const updates = {};
        // const referrerRef = ref(db, `users/${referrerUid}`); // Not used directly in update() call
        // const redeemerRef = ref(db, `users/${redeemerUid}`); // Not used directly in update() call

        // Increment referrer's referralCount
        updates[`/users/${referrerUid}/referralCount`] = (referrerData.referralCount || 0) + 1;
        // Add bonus coins to referrer
        updates[`/users/${referrerUid}/totalCoins`] = (referrerData.totalCoins || 0) + REFERRER_BONUS;

        // Add bonus coins to redeemer (total is signup + redeemer bonus)
         // The initial redeemerData already includes the signup bonus.
        updates[`/users/${redeemerUid}/totalCoins`] = redeemerData.totalCoins + REDEEMER_BONUS; // Add redeemer bonus
        // Mark redeemer as having redeemed a code
        updates[`/users/${redeemerUid}/referralRedeemed`] = true;
        updates[`/users/${redeemerUid}/codeRedeemedFrom`] = referrerUid;


        console.log("Performing atomic update for referral redemption:", JSON.stringify(updates, null, 2));

        await update(ref(db), updates); // Use update on the root reference for multiple paths

        console.log("Referral redemption successful in DB.");

        // Return the new coin count for the redeemer so the local state can be updated immediately
        return {
            newCoinsForRedeemer: redeemerData.totalCoins + REDEEMER_BONUS,
            referrerUid: referrerUid
        };
    }


    // --- Withdraw Logic ---
    let selectedWithdrawCoins = 0; let selectedWithdrawPKR = 0;

    // *** REVISED: updateWithdrawalOptionStates ***
    function updateWithdrawalOptionStates() {
        const user = auth.currentUser;
        const isLoggedInAndProfileComplete = user && currentUsername;

        if (!redeemOptionsDiv) {
            console.error("Redeem options container not found!");
            return;
        }

        redeemOptionsDiv.querySelectorAll('.redeem-option').forEach(button => {
            const coinsNeeded = parseInt(button.dataset.coins, 10);
            button.classList.remove('available-option', 'redeemed-once'); // Reset highlight and one-time class
            button.disabled = false; // Assume enabled initially for checks
            button.title = ""; // Reset title

            if (!isLoggedInAndProfileComplete) {
                button.disabled = true;
                button.title = "Log in & complete profile to withdraw.";
                return; // Skip further checks if not logged in
            }

            // --- Handle 10k Option (One-Time) ---
            if (coinsNeeded === 10000) {
                const oneTimeSpan = button.querySelector('.one-time-text');
                if (hasRedeemed10kOnce) {
                    button.disabled = true;
                    button.classList.add('redeemed-once');
                    button.title = "This option has already been redeemed.";
                     if (oneTimeSpan) oneTimeSpan.textContent = '(Redeemed)';
                } else if (totalCoins < coinsNeeded) {
                    button.disabled = true;
                    button.title = `Need ${coinsNeeded - totalCoins} more coins for this one-time withdrawal`;
                    if (oneTimeSpan) oneTimeSpan.textContent = '(One-Time)'; // Still one-time if not enough coins
                } else {
                    // Check initial referral requirement for 10k
                    const initialReferralsNeeded10k = withdrawalRequirements[10000] ?? 0;
                     if (currentReferralCount < initialReferralsNeeded10k) {
                        button.disabled = true;
                        button.title = `Need ${initialReferralsNeeded10k - currentReferralCount} more refs (${currentReferralCount}/${initialReferralsNeeded10k}) for the 10k option`;
                        if (oneTimeSpan) oneTimeSpan.textContent = '(One-Time)';
                     } else {
                         // Coins >= 10k AND Referrals >= base 10k requirement
                         button.classList.add('available-option');
                          // No title needed if fully available
                          if (oneTimeSpan) oneTimeSpan.textContent = '(Ready)'; // Indicate ready
                     }
                }
                // Ensure one-time text is visible for the 10k option
                 if (oneTimeSpan) oneTimeSpan.style.display = 'inline';
                return; // Move to next button
            }

            // --- Handle Higher Tier Options (Dynamic Referrals) ---
            const baseReferralsNeeded = withdrawalRequirements[coinsNeeded]; // Use actual requirement from map
            // If coinsNeeded doesn't exist in withdrawalRequirements (e.g., invalid button data), treat it as impossible.
            if (baseReferralsNeeded === undefined) {
                 console.warn("Invalid coinsNeeded in redeem option:", coinsNeeded);
                 button.disabled = true;
                 button.title = "Invalid option.";
                 const oneTimeSpan = button.querySelector('.one-time-text'); if (oneTimeSpan) oneTimeSpan.style.display = 'none';
                 return;
            }

            const actualReferralsNeeded = baseReferralsNeeded + successfulDynamicWithdrawals; // Dynamic requirement
            actualReferralsNeeded = Math.max(0, actualReferralsNeeded); // Ensure it's not negative

             // Check Coin Requirement
            if (totalCoins < coinsNeeded) {
                button.disabled = true;
                button.title = `Need ${coinsNeeded - totalCoins} more coins`;
            } else {
                 // Coin requirement met, now check Referral Requirement
                if (currentReferralCount < actualReferralsNeeded) {
                    button.disabled = true;
                    button.title = `Need ${actualReferralsNeeded - currentReferralCount} more refs (${currentReferralCount}/${actualReferralsNeeded}) for this tier`;
                 } else {
                    // Coins met AND Referrals met
                    button.classList.add('available-option');
                     // No title needed if fully available
                 }
            }
             // Ensure one-time text is hidden for non-10k options
             const oneTimeSpan = button.querySelector('.one-time-text');
             if (oneTimeSpan) {
                  oneTimeSpan.style.display = 'none';
             }
        });
    }

    withdrawBtn.addEventListener("click", () => {
        if (!auth.currentUser || !currentUsername) { showStatusMessage("Log in & complete profile.", "error"); return; }
         if (isProcessingAuth) { console.log("Ignoring Withdraw click while processing."); return; }

        showInterstitialAd(() => { // Show ad before opening withdraw modal
            console.log("Withdraw clicked. Ad shown, showing modal.");
            updateWithdrawalOptionStates(); // Update button states/styles just before showing
            redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
            referralTaskDisplay.innerHTML = ""; // Clear task display initially
            referralTaskDisplay.className = 'referralTaskDisplay'; // Clear task display classes
            redeemDetailsForm.reset();
            redeemSubmitBtn.disabled=false; // Ensure submit button is enabled initially
            redeemSubmitBtn.textContent="Submit Request";
            withdrawModal.style.display="block"; // Ensure modal opens
        });
    });
    closeWithdraw.addEventListener("click", () => { withdrawModal.style.display = "none"; });

     // Event listener for redeem option buttons using event delegation
     if (redeemOptionsDiv) {
         redeemOptionsDiv.addEventListener('click', (event) => {
             const button = event.target.closest('.redeem-option');
             if (!button) return; // Not a redeem option button

             // Button is disabled only if coins/10k used are insufficient or refs are insufficient (checked by updateWithdrawalOptionStates)
             if (button.disabled) {
                 showStatusMessage(button.title || "Cannot select this option.", "error", 4000);
                 return;
             }
             if (isProcessingAuth) { console.log("Ignoring redeem option click while processing."); return; }


            selectedWithdrawCoins = parseInt(button.dataset.coins, 10);
            selectedWithdrawPKR = parseInt(button.dataset.pkr, 10);

            if(isNaN(selectedWithdrawCoins) || isNaN(selectedWithdrawPKR) || selectedWithdrawCoins <= 0) {
                console.error("Invalid button data:", button.dataset);
                showStatusMessage("Error selecting option.", "error"); return;
            }

            console.log(`Selected: ${selectedWithdrawCoins} coins.`);

            const baseReferralsNeeded = withdrawalRequirements[selectedWithdrawCoins];
             // If coinsNeeded doesn't exist in withdrawalRequirements, handle as invalid
             if (baseReferralsNeeded === undefined) {
                 console.error("Invalid coinsNeeded in redeem option click:", selectedWithdrawCoins);
                 showStatusMessage("Error selecting option.", "error");
                 // Reset form to options view
                 redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
                 return;
             }

            // Calculate actual required referrals dynamically
             let actualReferralsNeeded;
             if (selectedWithdrawCoins === 10000) {
                 actualReferralsNeeded = baseReferralsNeeded; // 10k uses base requirement
             } else {
                 actualReferralsNeeded = (baseReferralsNeeded ?? 0) + successfulDynamicWithdrawals; // Higher tiers add successful dynamic withdrawals
             }
              // Ensure actualReferralsNeeded is never negative (shouldn't happen with current logic, but safety)
             actualReferralsNeeded = Math.max(0, actualReferralsNeeded);


            // --- Populate Referral Task Display ---
            const hasEnoughReferrals = currentReferralCount >= actualReferralsNeeded;
            referralTaskDisplay.className = 'referralTaskDisplay'; // Clear previous classes
             if (selectedWithdrawCoins === 10000) {
                  referralTaskDisplay.innerHTML = `<strong>Task:</strong> Invite ${baseReferralsNeeded} friends`; // 10k task is fixed
             } else {
                  referralTaskDisplay.innerHTML = `<strong>Task:</strong> Invite ${actualReferralsNeeded} friends`; // Dynamic task
             }


            if (hasEnoughReferrals) {
                referralTaskDisplay.classList.add('task-complete');
                 referralTaskDisplay.innerHTML += ` <span class="status-icon">✔</span><br>(Completed: ${currentReferralCount}/${actualReferralsNeeded} referrals)`;
            } else {
                referralTaskDisplay.classList.add('task-incomplete');
                 referralTaskDisplay.innerHTML += ` <span class="status-icon">❌</span><br>(Required: ${actualReferralsNeeded - currentReferralCount} more. Have: ${currentReferralCount})`; // Corrected message text
            }
            // --- End Populate Referral Task Display ---

            // We still show the form even if referrals aren't met here, but submission will be blocked by the submit handler.
            // This allows the user to see the required task.
            redeemOptionsDiv.style.display='none';
            redeemFormDiv.style.display='block';
            redeemFormDiv.querySelector('h3').textContent = `Redeem ${selectedWithdrawCoins} Coins for ${selectedWithdrawPKR} PKR`;
         });
     } else {
          console.error("Failed to attach click listeners to withdrawal options: redeemOptionsDiv not found.");
     }


    // *** REVISED: redeemDetailsForm Submit Handler (Referral check remains crucial here) ***
    redeemDetailsForm.addEventListener('submit', (e) => {
         e.preventDefault();

         const user=auth.currentUser; if(!user){ showStatusMessage("Authentication error.", "error"); withdrawModal.style.display="none"; return; }
         if (isProcessingAuth) { console.log("Ignoring submit click while processing."); return; }


         const name = accountHolderName.value.trim();
         const number = accountNumber.value.trim();
         const paymentMethodInput = document.querySelector('input[name="paymentMethod"]:checked');

         if(!name || !number || !paymentMethodInput){ showStatusMessage("Please fill all details.", "error"); return; }
         if(!/^\d+$/.test(number)) { showStatusMessage("Account number is invalid.", "error"); return; }

         // --- START: Final Checks Before Submission ---
         const coinsToWithdraw = selectedWithdrawCoins;
         const baseReferralsNeeded = withdrawalRequirements[coinsToWithdraw];
         if (baseReferralsNeeded === undefined) {
              console.error("Cannot find base referral requirement for final check:", coinsToWithdraw);
              showStatusMessage("Error processing request. Invalid selection.", "error");
              // Reset form to options view
              redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
              return;
         }

         // Calculate actual required referrals dynamically for the check
         let actualReferralsNeeded;
         if (coinsToWithdraw === 10000) {
              actualReferralsNeeded = baseReferralsNeeded; // 10k uses base requirement
         } else {
              actualReferralsNeeded = (baseReferralsNeeded ?? 0) + successfulDynamicWithdrawals; // Higher tiers add successful dynamic withdrawals
         }
          // Ensure actualReferralsNeeded is never negative (shouldn't happen with current logic, but safety)
         actualReferralsNeeded = Math.max(0, actualReferralsNeeded);


         // Check 10k specific rule first
         if (coinsToWithdraw === 10000) {
             if (hasRedeemed10kOnce) {
                  showStatusMessage("You have already redeemed the 10k option.", "error", 5000);
                  // Reset form to options view
                  redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
                  return;
             }
             // For 10k, check against the base requirement only
             if (currentReferralCount < actualReferralsNeeded) { // actualRefNeeded is base for 10k
                  showStatusMessage(`Referral task incomplete! Need ${actualReferralsNeeded - currentReferralCount} more friends for the 10k option.`, "error", 5000);
                   // Update the task display again just in case (optional, but helpful)
                 referralTaskDisplay.classList.remove('task-complete');
                 referralTaskDisplay.classList.add('task-incomplete');
                 referralTaskDisplay.innerHTML = `<strong>Task:</strong> Invite ${actualReferralsNeeded} friends <span class="status-icon">❌</span><br>(Required: ${actualReferralsNeeded - currentReferralCount} more. Have: ${currentReferralCount})`;
                  return; // Prevent submission
             }
         } else {
             // For tiers > 10k, check against the dynamic requirement
              if (currentReferralCount < actualReferralsNeeded) {
                  showStatusMessage(`Referral task incomplete! Need ${actualReferralsNeeded - currentReferralCount} more friends for this withdrawal tier.`, "error", 5000);
                   // Update the task display again just in case
                 referralTaskDisplay.classList.remove('task-complete');
                 referralTaskDisplay.classList.add('task-incomplete');
                 referralTaskDisplay.innerHTML = `<strong>Task:</strong> Invite ${actualReferralsNeeded} friends <span class="status-icon">❌</span><br>(Required: ${actualReferralsNeeded - currentReferralCount} more. Have: ${currentReferralCount})`; // Corrected message text
                  return; // Prevent submission
              }
         }

         // Final coin check (should still be sufficient, but good practice)
         if(totalCoins < coinsToWithdraw){
              showStatusMessage(`Insufficient coins. Need ${coinsToWithdraw} (${totalCoins}).`, "error", 5000);
              // Reset form to options view
              redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
              return;
         }

         // --- END: Final Checks Before Submission ---

         const method = paymentMethodInput.value; const timestamp = serverTimestamp();
         const requestData = { uid: user.uid, email: user.email || "N/A", username: currentUsername || "N/A", withdrawalAmountCoins: coinsToWithdraw, pkrAmount: selectedWithdrawPKR, accountHolderName: name, accountNumber: number, paymentMethod: method, status: "pending", referralsAtRequest: currentReferralCount, successfulDynamicWithdrawalsAtRequest: successfulDynamicWithdrawals, timestamp: timestamp }; // Added current dynamic withdrawal count

         console.log("Attempting to save withdrawal request:", JSON.stringify(requestData, null, 2)); // Log request data

         redeemSubmitBtn.disabled = true; redeemSubmitBtn.textContent = "Submitting..."; setAuthProcessing(true); showStatusMessage("Processing request...", "info"); // Set processing during DB operation

         // Use update for atomic decrement and request creation + status updates
         const updates = {};
         const newTotalCoins = totalCoins - coinsToWithdraw;
         const newRequestKey = push(ref(db, 'withdrawRequests')).key;

         updates[`/users/${user.uid}/totalCoins`] = newTotalCoins;
         updates[`/withdrawRequests/${newRequestKey}`] = requestData;

          // Add withdrawal status updates based on the tier
         if (coinsToWithdraw === 10000) {
             updates[`/users/${user.uid}/hasRedeemed10kOnce`] = true;
         } else { // For tiers > 10k
             // Increment successfulDynamicWithdrawals atomically
             updates[`/users/${user.uid}/successfulDynamicWithdrawals`] = successfulDynamicWithdrawals + 1;
         }


         console.log("Update object for Firebase:", JSON.stringify(updates, null, 2)); // Log update object

         update(ref(db), updates).then(() => {
            console.log(`Withdraw request ${newRequestKey} submitted and user coins/status updated for UID: ${requestData.uid}. New coin total on server: ${newTotalCoins}`);
            showStatusMessage(`Request submitted successfully! Status: Pending.`, "success", 5000);
            // The RT listener will update local state variables (totalCoins, hasRedeemed10kOnce, successfulDynamicWithdrawals)
            // and trigger updateWithdrawalOptionStates().
            withdrawModal.style.display = "none";
         }).catch(err => {
            showStatusMessage("Submission failed: "+err.message, "error", 5000);
            console.error("Withdraw submission error:", err);
            // Reset form to options view on failure
            redeemOptionsDiv.style.display="block"; redeemFormDiv.style.display="none";
         }).finally(() => {
             redeemSubmitBtn.disabled = false;
             redeemSubmitBtn.textContent = "Submit Request";
              setAuthProcessing(false); // Reset processing after DB operation finishes
         });
    });

    // --- Info Modal ---
    infoBtn.addEventListener("click", () => {
         if (isProcessingAuth) { console.log("Ignoring Info click while processing."); return; }
         showInterstitialAd(() => { // Show ad before opening info modal
              console.log("Info clicked. Ad shown, showing modal.");
              infoModal.style.display = "block";
         });
    });
    closeInfo.addEventListener("click", () => { infoModal.style.display = "none"; });

    // --- Logout ---
    logoutBtn.addEventListener("click", () => {
         console.log("Logout clicked.");
         if (isProcessingAuth) { console.log("Ignoring Logout click while processing."); return; }
         showInterstitialAd(() => { // Show ad before logging out
              console.log("Logout clicked. Ad shown, logging out.");
              setAuthProcessing(true); showStatusMessage("Logging out...", "info", 1500);
              signOut(auth).then(() => { showStatusMessage("Logged out.", "info"); console.log("SignOut ok."); }).catch((e) => { showStatusMessage("Logout error: "+e.message, "error"); console.error("Sign out error:", e); setAuthProcessing(false); });
         });
    });

    // NEW: Android App Button Listener
    if (androidAppBtn) {
        androidAppBtn.addEventListener("click", () => {
            // No ad needed for simple link click
            window.open(androidAppDownloadLink, "_blank");
        });
    }


    // --- Game Engine ---
    const ctx = gameCanvas.getContext("2d");
    // Remove allImagesLoaded flag as game starting issue likely not related to asset loading blocking
    function resizeCanvas() { gameCanvas.width=window.innerWidth; const bannerHeight=document.getElementById('bannerAdContainer')?.offsetHeight||50; gameCanvas.height=window.innerHeight-bannerHeight; if(gameStarted&&mario){const groundY=gameCanvas.height-50; if(mario.y+mario.height>=groundY-5){mario.y=groundY-mario.height;mario.dy=0;if(mario.isJumping){mario.isJumping=false;canDoubleJump=false;}}} } window.addEventListener("resize", resizeCanvas);
    const imagesToLoad = { character:"https://i.imgur.com/AbfH2aB.png", background:"https://i.imgur.com/xZpZqGt.png", enemy:"https://i.imgur.com/TsR4WXH.png", coin:"https://i.imgur.com/cMQ9X0d.png", platform:"https://i.imgur.com/06ptzal.png" }; const gameImages = {}; let imagesLoadedCount = 0; let totalImagesToLoad = Object.keys(imagesToLoad).length;
    // Simplified image loading check - buttons are enabled regardless, rely on draw functions checking .complete
    // Let's keep the game assets loaded count, might be useful for other things or future checks
    let gameAssetsLoaded = false;
    function checkGameAssetsLoaded() {
         imagesLoadedCount++;
         console.log(`Game asset loaded (${imagesLoadedCount}/${totalImagesToLoad})`);
         if (imagesLoadedCount === totalImagesToLoad) {
             gameAssetsLoaded = true;
             console.log("All game assets loaded.");
             // No longer enabling buttons here, they are enabled initially
         }
    }
    console.log("Loading game assets...");
    // No longer disabling buttons here
    for (const key in imagesToLoad) {
        gameImages[key] = new Image();
        gameImages[key].onload = checkGameAssetsLoaded;
        gameImages[key].onerror = () => {
             console.error(`Failed load: ${key}`);
             totalImagesToLoad--; // Decrement total if one fails, so we still know when *attempted* loads are done
             showStatusMessage(`Warning: Could not load asset: ${key}. Game may not display correctly.`, "warning", 7000);
        };
        gameImages[key].src = imagesToLoad[key];
    }


    // Updated initGame to remove allImagesLoaded check
    function initGame() {
        // Keep this check for critical missing assets if needed, or rely on draw function checks
        // if (!gameAssetsLoaded) { showStatusMessage("Game assets still loading or failed.", "info"); return; } // Optional check if needed
        if (gameStarted) return; // Prevent multiple calls if user double clicks start
        console.log("Initializing game...");
        resizeCanvas();
        bgX = 0;
        platformX = 0;
        const groundY = gameCanvas.height - 50;
        mario = { x: 60, y: groundY - 60, width: 40, height: 60, dy: 0, gravity: 1.6, jumpPower: -22, doubleJumpPower: -18, isJumping: false, onGround: true };
        obstacles = [];
        coins = [];
        speed = 6;
        score = 0;
        gameOver = false;
        gameStarted = true;
        lastJumpInputTime = 0;
        canDoubleJump = false;
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        playBackgroundMusic();
        console.log("Game initialized. Starting loop.");
        gameLoop(); // Start the game loop
         // Hide fixed buttons and status during game
        if (whatsappBtn) whatsappBtn.style.display = 'none';
        if (spinWheelBtn) spinWheelBtn.style.display = 'none';
        topRightStatus.style.display = 'none';
     }
    function drawBackground() { if (!gameImages.background?.complete || gameImages.background.naturalHeight === 0) { ctx.fillStyle = '#60a5fa'; ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height); return; }; bgX = (bgX - speed * 0.4) % gameImages.background.width; ctx.drawImage(gameImages.background, bgX, 0, gameImages.background.width, gameCanvas.height); ctx.drawImage(gameImages.background, bgX + gameImages.background.width, 0, gameImages.background.width, gameCanvas.height); }
    function drawPlatform() { if (!gameImages.platform?.complete || gameImages.platform.naturalHeight === 0) { ctx.fillStyle = '#E0A070'; ctx.fillRect(0, gameCanvas.height - 50, gameCanvas.width, 50); return; }; platformX = (platformX - speed) % gameImages.platform.width; ctx.drawImage(gameImages.platform, platformX, gameCanvas.height - 50, gameImages.platform.width, 50); ctx.drawImage(gameImages.platform, platformX + gameImages.platform.width, gameCanvas.height - 50, gameImages.platform.width, 50); }
    function drawMario() { if(!mario || !gameImages.character?.complete || gameImages.character.naturalHeight === 0) return; ctx.drawImage(gameImages.character, mario.x, mario.y, mario.width, mario.height); }
    function drawObstacles() { if (!gameImages.enemy?.complete || gameImages.enemy.naturalHeight === 0) return; for (let i = obstacles.length - 1; i >= 0; i--){ let obs = obstacles[i]; obs.x -= speed; ctx.drawImage(gameImages.enemy, obs.x, obs.y, obs.width, obs.height); if(obs.x + obs.width < 0) obstacles.splice(i, 1); } }
    function spawnObstacles() { if(gameOver || !gameImages.enemy?.complete || gameImages.enemy.naturalHeight === 0) return; const bMin=350, bMax=650; const dF=Math.max(0.3,1-(score/1000)); const cMin=bMin*dF, cMax=bMax*dF; const dR=Math.max(50,cMax-cMin); const rD=cMin+Math.random()*dR; let lastX=-rD; if(obstacles.length>0) lastX=obstacles[obstacles.length-1].x; if(gameCanvas.width-lastX>rD && obstacles.length<5){ const gY=gameCanvas.height-50; obstacles.push({x:gameCanvas.width+10,y:gY-50,width:50,height:50}); } }
    function spawnCoins() {
        if(!gameImages.coin?.complete || gameImages.coin.naturalHeight === 0 || gameOver) return;
        const spawnChance = 0.014; // REDUCED chance
        const maxGroups = 3;
        if(coins.length < (maxGroups * 2) && Math.random() < spawnChance) {
            const groundY = gameCanvas.height - 50; let startY; const hChance=Math.random();
            if(hChance<0.5) startY=groundY-30; else if(hChance<0.85) startY=groundY-100-(Math.random()*40); else startY=groundY-160-(Math.random()*50);
            let coinCount = Math.floor(Math.random() * 2) + 1; // REDUCED: 1 to 2 coins
            let startX = gameCanvas.width + Math.random() * 150; const spacing = 45;
            for(let i=0; i<coinCount; i++) coins.push({x:startX+i*spacing,y:startY,width:25,height:25});
        }
    }
    function drawCoinsAndCollect() { if (!gameImages.coin?.complete || gameImages.coin.naturalHeight === 0 || !mario || gameOver) return; for (let i = coins.length - 1; i >= 0; i--) { let c = coins[i]; c.x -= speed; ctx.drawImage(gameImages.coin, c.x - c.width / 2, c.y - c.height / 2, c.width, c.height); if (mario.x < c.x + c.width / 2 && mario.x + mario.width > c.x - c.width / 2 && mario.y < c.y + c.height / 2 && mario.y + mario.height > c.y - c.height / 2) { coins.splice(i, 1); score += 1; playSound(coinSound); } else if (c.x + c.width / 2 < 0) coins.splice(i, 1); } }
    function applyPhysics() { if(!mario || gameOver) return; mario.dy += mario.gravity; mario.y += mario.dy; const groundY = gameCanvas.height - 50; if (mario.y + mario.height >= groundY) { mario.y = groundY - mario.height; mario.dy = 0; mario.onGround = true; if(mario.isJumping) { mario.isJumping = false; canDoubleJump = false; } } else mario.onGround = false; if (mario.y < 0) { mario.y = 0; mario.dy = 0; } }
    function checkCollision() { if(!mario || gameOver) return; for(let i = obstacles.length - 1; i >= 0; i--){ let obs = obstacles[i]; const mX=mario.x+5, mY=mario.y+5, mW=mario.width-10, mH=mario.height-10; const oX=obs.x+5, oY=obs.y+5, oW=obs.width-10, oH=obs.height-10; if (mX < oX + oW && mX + mW > oX && mY < oY + oH && mY + mH > oY) { console.log("Collision!"); gameOver = true; stopBackgroundMusic(); break; } } }
    function jump() { if(!gameStarted || gameOver || !mario) return; const now = Date.now(); if (mario.isJumping && !mario.onGround && canDoubleJump && (now - lastJumpInputTime < doubleJumpWindow)) { mario.dy = mario.doubleJumpPower; canDoubleJump = false; lastJumpInputTime = 0; console.log("Double Jump!"); playSound(jumpSound); } else if (mario.onGround) { mario.dy = mario.jumpPower; mario.isJumping = true; mario.onGround = false; canDoubleJump = true; lastJumpInputTime = now; console.log("First Jump!"); playSound(jumpSound); } }
    function gameLoop() {
        // Added try/catch to gameLoop to prevent silent failures from stopping the loop
        try {
            if(gameOver || !gameStarted) { if (gameOver) handleGameOver(); return; }
            applyPhysics();
            checkCollision();
            if (gameOver) { handleGameOver(); return; } // Check game over again after collision

            spawnObstacles();
            spawnCoins();
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            drawBackground();
            drawPlatform();
            drawObstacles();
            drawCoinsAndCollect();
            drawMario();

            ctx.fillStyle="#FFF";
            ctx.font="18px 'Press Start 2P'"; // Slightly larger score font
            ctx.textAlign="left"; ctx.textBaseline="top"; ctx.shadowColor='rgba(0,0,0,0.8)'; ctx.shadowBlur=5; ctx.shadowOffsetX=2; ctx.shadowOffsetY=2;
            ctx.fillText("Score: " + score, 25, 25); // Draw score with more padding
            ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;

            animationFrameId = requestAnimationFrame(gameLoop);
        } catch (error) {
            console.error("Error in gameLoop:", error);
            gameOver = true; // Force game over on error
            handleGameOver(); // Handle game over state
            showStatusMessage("Game encountered an error.", "error", 5000);
        }
    }
    function handleGameOver() {
        console.log(`Game Over! Score: ${score}`); gameStarted = false; gameOver = true;
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        const user = auth.currentUser;
        if (user && score > 0 && currentUsername) {
            const userRef = ref(db, `users/${user.uid}`);
            // Update local state for display immediately
            totalCoins += score;
            // Update DB with the new total coins
            update(userRef, { totalCoins: totalCoins })
            .then(() => console.log(`Score submitted. Local state updated. RT listener might sync shortly.`))
            .catch(e => { console.error("Error saving score:", e); showStatusMessage("Error saving score.", "error"); });
        } else if (user && score === 0) { console.log("Score 0, no save needed."); }
        else { console.log("Guest or incomplete profile, score not saved."); }
        showGameOverMenu(); console.log("Game Over Menu shown.");
    }

    // --- Game Control Buttons ---
    startBtn.addEventListener("click", (e) => { // Added e parameter
         e.preventDefault(); // Prevent default button behavior
         if (isProcessingAuth) { console.log("Ignoring Start click while processing."); return; }
         // No longer checking allImagesLoaded explicitly blocking start button
         // if (!gameAssetsLoaded) { showStatusMessage("Game assets still loading.", "info"); return; } // Optional check if needed
         if (gameStarted) return;
         console.log("Start clicked.");
         showInterstitialAd(() => {
             console.log("Ad callback: Starting game.");
             mainMenu.style.display = "none";
             gameCanvas.style.display = 'block';
             initGame(); // Call initGame to start the game engine
         });
    });
    // No ad on Restart button as requested
    restartBtn.addEventListener("click", () => {
         if (isProcessingAuth) { console.log("Ignoring Restart click while processing."); return; }
         // No longer checking allImagesLoaded explicitly blocking restart button
         // if (!gameAssetsLoaded) { showStatusMessage("Game assets error.", "error"); showMainMenu(); return; } // Optional check
         if (gameStarted) return;
         console.log("Restart clicked.");
         console.log("Direct restart...");
         gameOverMenu.style.display = "none";
         gameCanvas.style.display = 'block';
         initGame(); // Call initGame to restart the game engine
    });
    backMenuBtn.addEventListener("click", () => {
         if (isProcessingAuth) { console.log("Ignoring Back to Menu click while processing."); return; }
         console.log("Back to Menu clicked.");
         showInterstitialAd(() => {
             console.log("Ad callback: Showing main menu.");
             showMainMenu();
         });
    });

    // --- Jump Listeners ---
    document.addEventListener("keydown", (e) => { if ((e.code === "Space" || e.code === "ArrowUp") && gameStarted && !gameOver) { e.preventDefault(); jump(); } });
    gameCanvas.addEventListener("click", (e) => { if (gameStarted && !gameOver) { e.preventDefault(); jump(); } });
    gameCanvas.addEventListener("touchstart", (e) => { if (gameStarted && !gameOver) { e.preventDefault(); jump(); } }, { passive: false });

    // --- Initial Setup on Page Load ---
    function initializeAppUI() {
        console.log("Initializing UI (Google Sign-in)...");
        mainMenu.style.display = "none"; gameCanvas.style.display = "none"; gameOverMenu.style.display = "none"; completeProfileModal.style.display = 'none'; spinWheelModal.style.display = 'none'; withdrawalHistoryModal.style.display = 'none'; settingsModal.style.display = 'none'; profileModal.style.display = 'none'; inviteModal.style.display = 'none'; withdrawModal.style.display = 'none'; infoModal.style.display = 'none'; // Hide all modals initially

         // Hide fixed buttons initially
        if (whatsappBtn) whatsappBtn.style.display = 'none';
        if (spinWheelBtn) spinWheelBtn.style.display = 'none';

        // setAuthProcessing(true); // REMOVED: Don't disable buttons initially

        updateSoundButton(); updateInviteLinkDisplay();
        // Game buttons are enabled initially now, assuming assets load
        // if (startBtn) startBtn.disabled = true; if (restartBtn) restartBtn.disabled = true; // REMOVED: Keep game buttons disabled until assets load


         // Initial auth state check determines what screen to show
         // The global onAuthStateChanged listener handles the initial display based on auth state.
         // We don't need to duplicate the logic here, just ensure the listener is active.

        // Initial display should be the login panel until auth state resolves
        googleSignInPanel.style.display = "flex";

        // Ensure top right status is handled by the onAuthStateChanged listener
        // It will be hidden initially if no user/profile, shown if logged in with profile, or shown for guests
        updateTopRightStatus(); // Update display placeholders if not logged in (will show 0s for guest)

        // Check URL for referral code on load
        checkUrlForReferral();

        console.log("Initial UI setup complete. Waiting for auth state.");
        // setAuthProcessing(false) is called by the onAuthStateChanged listener when it resolves
    }
    initializeAppUI();

    // --- Auth State Change Listener ---
    onAuthStateChanged(auth, (user) => {
        console.log("onAuthStateChanged:", user ? user.uid : "Logged out");
        // setAuthProcessing(true); // Already set in initializeAppUI or previous state transition

        if (user) {
            // User is signed in
            // Check if profile is complete or load data
            const userRef = ref(db, `users/${user.uid}`);
            get(userRef).then(snapshot => {
                if (snapshot.exists() && snapshot.val().username) {
                     // Profile complete, load data and show main menu
                     console.log("User logged in with complete profile.");
                     loadUserData(user.uid)
                        .then(() => {
                             setupUserDataListener(user.uid); // Start real-time listener
                             checkAndMergeGuestCooldown(user.uid); // Check guest cooldown after login
                             // setAuthProcessing(false); // Moved to after showMainMenu/setAuthProcessing(false) call
                             showMainMenu(); // Show main menu after loading data
                             setAuthProcessing(false); // End auth processing AFTER showing menu and updating buttons
                         })
                        .catch(e => {
                             console.error("Error loading user data after auth state change:", e);
                             showStatusMessage("Error loading profile data. Logging out.", "error");
                             setAuthProcessing(false); // End processing on error
                             signOut(auth).catch(signoutErr => console.error("Sign out error:", signoutErr));
                             // The onAuthStateChanged listener will catch the sign out and show the login screen
                        }); // No finally here, setAuthProcessing is inside then/catch

                } else if (snapshot.exists() && !snapshot.val().username) {
                    // User logged in but profile incomplete
                    console.log("User logged in with incomplete profile.");
                    // Show complete profile modal (this should already be handled if they just signed in via Google)
                     // If they land here on a refresh, show the modal.
                     googleSignInPanel.style.display = "none"; // Hide sign-in
                     mainMenu.style.display = "none"; // Hide menu
                     completeProfileModal.style.display = "block"; // Show complete profile
                     profileUsernameInput.value = user.displayName || "";
                     profileReferralInput.value = ""; // Clear referral input on refresh to avoid re-applying
                     // Re-attach or ensure profile completion handler is ready
                     if(profileCompleteListener) saveProfileBtn.removeEventListener('click', profileCompleteListener);
                     profileCompleteListener = createProfileCompletionHandler(user); saveProfileBtn.addEventListener('click', profileCompleteListener);

                    setAuthProcessing(false);

                } else {
                    // This state is unexpected if sign-in was recent but profile node is missing.
                    // Assume a critical error or old/corrupted data and log out.
                    console.error("User exists but profile node missing. Logging out.");
                     showStatusMessage("Profile data missing or corrupted. Logging out.", "error", 5000);
                     setAuthProcessing(false); // End processing
                     signOut(auth).catch(e => console.error("Sign out error:", e));
                     // onAuthStateChanged will handle showing login screen
                }
            }).catch(error => {
                 console.error("Error checking profile existence after auth state change:", error);
                 showStatusMessage("Error checking profile. Logging out.", "error");
                 setAuthProcessing(false); // End processing
                 signOut(auth).catch(e => console.error("Sign out error:", e));
                 // onAuthStateChanged will handle showing login screen
            });

        } else {
            // User is signed out
            console.log("User is signed out.");
            resetAppStateToLoggedOut(); // Reset local state and UI
            googleSignInPanel.style.display = "flex"; // Show sign-in panel
            mainMenu.style.display = "none";
            // Hide any open modals that require login
            settingsModal.style.display = 'none';
            profileModal.style.display = 'none';
            inviteModal.style.display = 'none';
            withdrawModal.style.display = 'none';
            withdrawalHistoryModal.style.display = 'none';
             // Info modal and Spin Wheel modal can stay open if user clicks them
            setAuthProcessing(false); // Ensure processing is off, enabling buttons on login panel
        }
    });

     // --- Generate Random Code Function (for invites) ---
     function generateRandomCode(length = 6) {
         const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0987654321'; // Removed 1234567
         let result = '';
         const charactersLength = characters.length;
         for (let i = 0; i < length; i++) {
             result += characters.charAt(Math.floor(Math.random() * charactersLength));
         }
         return result;
     }


  </script>

  <!-- Social Bar Script -->
  <script type='text/javascript' src='//pl26479822.profitableratecpm.com/11/f3/83/11f3830187c378aedebef88b0bcd83a0.js'></script>

</body>
</html>